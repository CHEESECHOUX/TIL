# CPU 성능 향상 기법

<ul>
    <li>빠른 CPU를 위한 설계 기법, 명령어 병렬 처리 기법을 학습</li>
    <li>RISC와 CISC의 차이에 대해 이해하기</li>
</ul>
<details>
    <summary><h2>1. 빠른 CPU를 위한 설계 기법</h2></summary>
    <br>
    <p><strong>클럭, 코어, 멀티코어, 하드웨어적 스레드, 소프트웨어적 스레드</strong> 개념 이해하고,<br>빠른 CPU를 만드는 설계 기법인 <strong>멀티코어 프로세서, 멀티스레드 프로세서</strong> 이해하기!</p>
    <ul>
    <br>
    <li>⭐️ <strong>멀티코어 프로세서</strong>: <strong>명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상</strong> 있는 <strong>CPU</strong></li>
    <li>⭐️ <strong>멀티스레드 프로세서</strong>: <strong>하나의 코어로 여러 개의 명령어를 동시에 실행</strong>할 수 있는 <strong>CPU</strong></li>
    </ul>
    <br>
    <h2>1-1. 클럭</h2>
    <p><strong>클럭 속도가 높은 CPU는 일반적으로 성능이 좋다. 그래서 클럭 속도는 CPU 속도 단위로 간주되기도 한다.</strong></p>
    <ol>
        <li>컴퓨터 부품들은 클럭 신호에 맞춰 일사불란하게 움직인다.</li>
        <li>CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다.</li>
    </ol>
    <p>→ 클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰 움직임.<br>
    클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것!</p>
    <br>
    <h3>✔️ 클럭 속도는 일정하지 않다.</h3>
    CPU는 계속 일정한 클럭 속도를 유지하기보다는 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮추기도 한다.<br>
    최대 클럭 속도를 강제로 더 끌어올릴 수도 있는데, 이런 기법을 <strong>오버클럭킹</strong>이라고 한다.</p>
    <br>
    <h3>✔️ 클럭 속도를 무지막지하게 높이면 무조건 CPU가 빨라질까?</h3>
    클럭 속도를 무작정 높이면 발열 문제가 심각해져, 클럭 속도만으로 CPU 성능을 올리는 데에 한계가 있다.</p>
    <br>
    <hr>
    <h2>1-2. 코어와 멀티코어</h2>
    <p>클럭 속도를 높이는 방법 외에 CPU의 성능을 높이는 대표적인 해결책으로는 ⭐️ <strong>CPU의 코어와 스레드 수를 늘리는 방법</strong>이 있다.</p>
    <br>
    <p><strong>오늘날의 CPU</strong>는 단순히 명령어를 실행하는 부품에서 <strong>명령어를 실행하는 부품을 여러 개 포함하는 부품</strong>으로 명칭의 범위가 확장 되었다.<br>
    → 8코어는 명령어를 실행하는 부품을 여덟 개 포함하고 있다고 보면 된다.</p>
    <ul>
    <li><strong>코어</strong>: <strong>명령어를 실행할 수 있는 하드웨어 부품</strong></li>
    <li><strong>멀티코어(멀티코어 프로세서)</strong>: <strong>코어</strong>(= 명령어를 실행할 수 있는 하드웨어 부품)<strong>가 두 개 이상 있는 CPU</strong></li>
    </ul>
    <br>
    <h3>✔️ 코어 개수만큼 연산 처리 속도가 배로 빨라질까?</h3>
    CPU의 연산 속도가 코어 수에 <strong>비례해 증가하지 않는다.</strong></p>
    <p>코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례해 연산 속도가 증가하지 않는다. 또한 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다.<br>
    중요한 것은 <strong>코어마다 처리할 명령어들을 얼마나 적절하게 분배하는지</strong> 이고 <strong>그에 따라 연산 속도는 크게 달라진다.</strong></p>
    <br>
    <hr>
    <h2>1-3. 스레드와 멀티스레드</h2>
    <ul>
    <li><strong>스레드</strong>: <strong>명령어를 실행하는 단위</strong></li>
    </ul>
    <p><strong>스레드에는 CPU에서 사용되는 하드웨어적 스레드</strong>가 있고, <strong>프로그램에서 사용되는 소프트웨어적 스레드</strong>가 있다.</p>
    <br>
    <h3>✔️ 하드웨어적 스레드(= CPU가 직접 처리하는 실행 단위)</h3>
    <p><strong>⭐️ 하나의 코어가 동시에 처리하는 명령어 단위</strong></p>
    <p>ex) 1코어 1스레드 CPU → 물리적으로 한 순간에 오직 <strong>명령어 1개</strong>만 처리<br>
    하드웨어적 스레드 = CPU가 실제로 병렬 처리할 수 있는 능력</p>
    <br>
    <h3>✔️ 소프트웨어적 스레드(= 운영체제가 제공하는 실행 단위)</h3>
    <p><strong>⭐️ 하나의 프로그램에서 독립적으로 실행되는 단위</strong></p>
    <ul>
        <li>하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있다.</li>
        <li><strong>한 번에 하나씩 명령어를 처리하는 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있다.</strong> (= 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행할 수 있다.)</li>
    </ul>
    <br>
    <h3>🤔 1코어 1스레드 CPU가 여러 스레드로 만들어진 프로그램을 실행할 수 있다.</h3>
    <ul>
        <li>전제 1: CPU는 코어 1개, 하드웨어 스레드 1개 → 물리적으로는 한 순간에는 <strong>명령어 1개</strong>만 처리</li>
        <li>전제 2: 프로그램은 내부적으로 <strong>스레드를 여러 개</strong> 만들어 <strong>동시에 작업</strong>을 진행하고 싶어함.</li>
    </ul>
    <br>
    <p>이때 운영체제가 해결사로 등장!</p>
    <ol>
        <li><strong>모든 스레드(= 소프트웨어 스레드)를 메모리에 올림</strong></li>
        <li><strong>짧은 시간 단위로 CPU를 번갈아 할당</strong><br>
            스레드 A를 1ms 실행 → 스레드 B를 1ms 실행 → 스레드 C를 1ms 실행 → 다시 A …</li>
        <li><strong>이 과정을 매우 빠른 속도로 반복</strong><br>
        <strong>인간이 체감하기엔 여러 스레드가 동시에 돌아가는 것처럼 보임.</strong></li>
    </ol>
    <p>이것이  <strong>컨텍스트 스위칭</strong>!</p>
    <br>
    <h3>✔️ 멀티스레드 프로세서(= 멀티스레드 CPU)</h3>
    <p><strong>하나의 코어로 여러 개의 명령어를 동시에 처리할 수 있는 CPU</strong></p>
    <p>ex) 8코어 16스레드: 명령어를 실행하는 부품을 여덟 개 포함하고, 한 번에 열여섯 개의 명령어를 처리할 수 있는 CPU를 의미</p>
    <ul>
    <li><strong>하이퍼스레딩</strong>: 인텔의 멀티스레드 기술을 의미</li>
    </ul>
    <br>
    <p>멀티스레드 프로세서를 설계하는 일은 매우 복잡하지만, 가장 큰 ⭐️ <strong>핵심은 레지스터</strong>이다.<br>
    <strong>하나의 코어로 여러 명령어를 동시에 처리하도록 만드려면</strong> 프로그램 카운터, 스택 포인터, 메모리 버퍼, 레지스터, 메모리 주소 레지스터와 같이 <strong>하나의 명령어를 처리하기 위해 꼭 필요한 레지스터들</strong>(= 레지스터 세트)<strong>을 여러 개 가지고 있으면 된다.</strong></p>
    <br>
    <p><strong>ALU와 제어 장치가 두 개의 레지스터 세트에 저장된 명령어를 해석하고 실행하면, 하나의 코어에서 두 개의 명령어가 동시에 실행된다.</strong><br>
        ex) 2코어 4스레드 CPU: 코어 2개, 코어당 레지스터 세트 2개(레지스터 총 4개)</p>
    <br>
    <h4>* 논리 프로세서</h4>
    <ul>
        <li><strong>논리 프로세서</strong>: <strong>운영체제가 하드웨어 스레드를 각각의 CPU처럼 인식한 단위</strong></li>
        <li>논리 프로세서 수 = 물리 코어 수 x 코어당 하드웨어 스레드 수<br>
    ex) 물리코어 x 코어당 하드웨어 스레드 = 논리 프로세서(= OS가 보는 CPU 수)<br>
        2 x 2 = 4  
</li>
    </ul>
    <br>
    <p>2코어 4스레드 CPU는 한 번에 네 개의 명령어를 처리할 수 있는데, <strong>프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 네 개 있는 것처럼 보인다.</strong> 그래서 하드웨어 스레드를 <strong>논리 프로세서</strong>라고 부르기도 한다.<br><br>
    실제 CPU 속에 명령어를 처리하는 부품(코어)는 2개지만, 각 코어가 스레드 2개를 동시에 처리할 수 있게 설계되어있다. 메모리 속 프로그램이 보기에는 (= 운영체제가 CPU를 스캔하면 CPU가 4개 있네! 라고 인식) → 논리 프로세서 4개로 표시되는 것.</p>

</details>
