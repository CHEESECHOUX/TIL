# CPU 성능 향상 기법

<ul>
    <li>빠른 CPU를 위한 설계 기법, 명령어 병렬 처리 기법을 학습</li>
    <li>RISC와 CISC의 차이에 대해 이해하기</li>
</ul>
<details>
    <summary><h2>1. 빠른 CPU를 위한 설계 기법</h2></summary>
    <br>
    <p><strong>클럭, 코어, 멀티코어, 하드웨어적 스레드, 소프트웨어적 스레드</strong> 개념 이해하고,<br>빠른 CPU를 만드는 설계 기법인 <strong>멀티코어 프로세서, 멀티스레드 프로세서</strong> 이해하기!</p>
    <ul>
    <br>
    <li>⭐️ <strong>멀티코어 프로세서</strong>: <strong>명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상</strong> 있는 <strong>CPU</strong></li>
    <li>⭐️ <strong>멀티스레드 프로세서</strong>: <strong>하나의 코어로 여러 개의 명령어를 동시에 실행</strong>할 수 있는 <strong>CPU</strong></li>
    </ul>
    <br>
    <h2>1-1. 클럭</h2>
    <p><strong>클럭 속도가 높은 CPU는 일반적으로 성능이 좋다. 그래서 클럭 속도는 CPU 속도 단위로 간주되기도 한다.</strong></p>
    <ol>
        <li>컴퓨터 부품들은 클럭 신호에 맞춰 일사불란하게 움직인다.</li>
        <li>CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다.</li>
    </ol>
    <p>→ 클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰 움직임.<br>
    클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것!</p>
    <br>
    <h3>✔️ 클럭 속도는 일정하지 않다.</h3>
    CPU는 계속 일정한 클럭 속도를 유지하기보다는 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮추기도 한다.<br>
    최대 클럭 속도를 강제로 더 끌어올릴 수도 있는데, 이런 기법을 <strong>오버클럭킹</strong>이라고 한다.</p>
    <br>
    <h3>✔️ 클럭 속도를 무지막지하게 높이면 무조건 CPU가 빨라질까?</h3>
    클럭 속도를 무작정 높이면 발열 문제가 심각해져, 클럭 속도만으로 CPU 성능을 올리는 데에 한계가 있다.</p>
    <br>
    <hr>
    <h2>1-2. 코어와 멀티코어</h2>
    <p>클럭 속도를 높이는 방법 외에 CPU의 성능을 높이는 대표적인 해결책으로는 ⭐️ <strong>CPU의 코어와 스레드 수를 늘리는 방법</strong>이 있다.</p>
    <br>
    <p><strong>오늘날의 CPU</strong>는 단순히 명령어를 실행하는 부품에서 <strong>명령어를 실행하는 부품을 여러 개 포함하는 부품</strong>으로 명칭의 범위가 확장 되었다.<br>
    → 8코어는 명령어를 실행하는 부품을 여덟 개 포함하고 있다고 보면 된다.</p>
    <ul>
    <li><strong>코어</strong>: <strong>명령어를 실행할 수 있는 하드웨어 부품</strong></li>
    <li><strong>멀티코어(멀티코어 프로세서)</strong>: <strong>코어</strong>(= 명령어를 실행할 수 있는 하드웨어 부품)<strong>가 두 개 이상 있는 CPU</strong></li>
    </ul>
    <br>
    <h3>✔️ 코어 개수만큼 연산 처리 속도가 배로 빨라질까?</h3>
    CPU의 연산 속도가 코어 수에 <strong>비례해 증가하지 않는다.</strong></p>
    <p>코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례해 연산 속도가 증가하지 않는다. 또한 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다.<br>
    중요한 것은 <strong>코어마다 처리할 명령어들을 얼마나 적절하게 분배하는지</strong> 이고 <strong>그에 따라 연산 속도는 크게 달라진다.</strong></p>
    <br>
    <hr>
    <h2>1-3. 스레드와 멀티스레드</h2>
    <ul>
    <li><strong>스레드</strong>: <strong>명령어를 실행하는 단위</strong></li>
    </ul>
    <p><strong>스레드에는 CPU에서 사용되는 하드웨어적 스레드</strong>가 있고, <strong>프로그램에서 사용되는 소프트웨어적 스레드</strong>가 있다.</p>
    <br>
    <h3>✔️ 하드웨어적 스레드(= CPU가 직접 처리하는 실행 단위)</h3>
    <p><strong>⭐️ 하나의 코어가 동시에 처리하는 명령어 단위</strong></p>
    <p>ex) 1코어 1스레드 CPU → 물리적으로 한 순간에 오직 <strong>명령어 1개</strong>만 처리<br>
    하드웨어적 스레드 = CPU가 실제로 병렬 처리할 수 있는 능력</p>
    <br>
    <h3>✔️ 소프트웨어적 스레드(= 운영체제가 제공하는 실행 단위)</h3>
    <p><strong>⭐️ 하나의 프로그램에서 독립적으로 실행되는 단위</strong></p>
    <ul>
        <li>하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있다.</li>
        <li><strong>한 번에 하나씩 명령어를 처리하는 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있다.</strong> (= 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행할 수 있다.)</li>
    </ul>
    <br>
    <h3>🤔 1코어 1스레드 CPU가 여러 스레드로 만들어진 프로그램을 실행할 수 있다.</h3>
    <ul>
        <li>전제 1: CPU는 코어 1개, 하드웨어 스레드 1개 → 물리적으로는 한 순간에는 <strong>명령어 1개</strong>만 처리</li>
        <li>전제 2: 프로그램은 내부적으로 <strong>스레드를 여러 개</strong> 만들어 <strong>동시에 작업</strong>을 진행하고 싶어함.</li>
    </ul>
    <br>
    <p>이때 운영체제가 해결사로 등장!</p>
    <ol>
        <li><strong>모든 스레드(= 소프트웨어 스레드)를 메모리에 올림</strong></li>
        <li><strong>짧은 시간 단위로 CPU를 번갈아 할당</strong><br>
            스레드 A를 1ms 실행 → 스레드 B를 1ms 실행 → 스레드 C를 1ms 실행 → 다시 A …</li>
        <li><strong>이 과정을 매우 빠른 속도로 반복</strong><br>
        <strong>인간이 체감하기엔 여러 스레드가 동시에 돌아가는 것처럼 보임.</strong></li>
    </ol>
    <p>이것이  <strong>컨텍스트 스위칭</strong>!</p>
    <br>
    <h3>✔️ 멀티스레드 프로세서(= 멀티스레드 CPU)</h3>
    <p><strong>하나의 코어로 여러 개의 명령어를 동시에 처리할 수 있는 CPU</strong></p>
    <p>ex) 8코어 16스레드: 명령어를 실행하는 부품을 여덟 개 포함하고, 한 번에 열여섯 개의 명령어를 처리할 수 있는 CPU를 의미</p>
    <ul>
    <li><strong>하이퍼스레딩</strong>: 인텔의 멀티스레드 기술을 의미</li>
    </ul>
    <br>
    <p>멀티스레드 프로세서를 설계하는 일은 매우 복잡하지만, 가장 큰 ⭐️ <strong>핵심은 레지스터</strong>이다.<br>
    <strong>하나의 코어로 여러 명령어를 동시에 처리하도록 만드려면</strong> 프로그램 카운터, 스택 포인터, 메모리 버퍼, 레지스터, 메모리 주소 레지스터와 같이 <strong>하나의 명령어를 처리하기 위해 꼭 필요한 레지스터들</strong>(= 레지스터 세트)<strong>을 여러 개 가지고 있으면 된다.</strong></p>
    <br>
    <p><strong>ALU와 제어 장치가 두 개의 레지스터 세트에 저장된 명령어를 해석하고 실행하면, 하나의 코어에서 두 개의 명령어가 동시에 실행된다.</strong><br>
        ex) 2코어 4스레드 CPU: 코어 2개, 코어당 레지스터 세트 2개(레지스터 총 4개)</p>
    <br>
    <h4>* 논리 프로세서</h4>
    <ul>
        <li><strong>논리 프로세서</strong>: <strong>운영체제가 하드웨어 스레드를 각각의 CPU처럼 인식한 단위</strong></li>
        <li>논리 프로세서 수 = 물리 코어 수 x 코어당 하드웨어 스레드 수<br>
    ex) 물리코어 x 코어당 하드웨어 스레드 = 논리 프로세서(= OS가 보는 CPU 수)<br>
        2 x 2 = 4  
</li>
    </ul>
    <br>
    <p>2코어 4스레드 CPU는 한 번에 네 개의 명령어를 처리할 수 있는데, <strong>프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 네 개 있는 것처럼 보인다.</strong> 그래서 하드웨어 스레드를 <strong>논리 프로세서</strong>라고 부르기도 한다.<br><br>
    실제 CPU 속에 명령어를 처리하는 부품(코어)는 2개지만, 각 코어가 스레드 2개를 동시에 처리할 수 있게 설계되어있다. 메모리 속 프로그램이 보기에는 (= 운영체제가 CPU를 스캔하면 CPU가 4개 있네! 라고 인식) → 논리 프로세서 4개로 표시되는 것.</p>

</details>

<details>
    <summary><h2>2. 명령어 병렬 처리 기법</h2></summary>
    <p>빠른 CPU를 만드려면 높은 클럭 속도에 멀티코어, 멀티스레드를 지원하는 CPU를 만드는 것도 중요하지만, <strong>CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요하다.</strong></p>
    <ul>
        <li><strong>명령어 병렬 처리 기법: 명령어를 동시에 처리해 CPU를 한시도 쉬지 않고 작동시키는 기법</strong></li>
        <li>대표적인 명령어 병렬 처리 기법: <strong>명령어 파이프 라이닝, 슈퍼스칼라, 비순차적 명령어 처리</strong></li>
    </ul>
    <br>
    <h2>1. 명령어 파이프 라이닝</h2>
    <ul>
        <li><strong>여러 명령어를 단계별로 겹쳐 실행해, CPU의 처리 효율과 명령어 처리 속도를 높이는 기법</strong></li>
    </ul>
    <br>
    <h4>✔️ 명령어가 처리되는 전체 과정 (명령어 처리 과정을 클럭 단위를 나눈다면)</h4>
    <ol>
        <li>명령어 인출</li>
        <li>명령어 해석</li>
        <li>명령어 실행</li>
        <li>결과 저장</li>
    </ol>
    <br>
    <p><strong>같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다!</strong><br>
        예를 들어 CPU는 한 명령어를 '인출'하는 동안에 다른 명령어를 '실행'할 수 있고, 한 명령어가 '실행'되는 동안에 연산 결과를 '저장'할 수 있다.
    </p>
    <br>
    <h2>✔️ 파이프라인 위험</h2>
    <ul>
        <li><strong>파이프라이닝이</strong> 높은 성능을 가져오기는 하지만, <strong>특정 상황에서는 성능 향상에 실패하는 경우</strong></li>
        <li><strong>데이터 위험, 제어 위험, 구조적 위험</strong>이 있다.</li>
    </ul>
    <br>
    <h3>1. 데이터 위험</h3>
    <ul>
        <li><strong>데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것</strong></li>
        <li>명령어 간 <strong>데이터 의존성에 의해 발생</strong>한다.</li>
        <li>어떤 명령어는 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우가 있다.</li>
    </ul>
    <br>
    <h3>2. 제어 위험</h3>
    <ul>
        <li>주로 분기 등으로 인한 <strong>프로그램 카운터의 갑작스러운 변화</strong>에 의해 발생한다.</li>
        <li>기본적으로 프로그램 카운터(PC)는 <strong>현재 실행 중인 명령어의 다음 주소</strong>로 자동 갱신 된다. 파이프라인은 이를 기준으로 <strong>다음 명령어를 미리 인출</strong>해 겹쳐 처리한다.<br>
        하지만 프로그램 실행 흐름을 바꾸는 <strong>분기 명령어</strong>가 등장하면, 실제로 분기가 일어날지(점프할지) 아니면 순차 실행을 이어갈지 <strong>분기 결과가 확정되기 전까지 알 수 없기 때문에</strong>, 
        미리 가져와 처리 중이던 명령어들이 무용지물이 되는 <strong>제어 위험</strong>이 발생한다.</li>
        <br>
        <li><strong>참고로 제어 위험을 위해 사용하는 기술</strong><br>
        <strong>- 분기 예측</strong>: 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술</p></li>
    </ul>
    <br>
    <h3>3. 구조적 위험(= 자원 위험)</h3>
    <ul>
        <li><strong>명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생</strong>한다.<br>
            (서로 다른 명령어가 동시에 같은 하드웨어 자원을 필요로 해서 충돌이 일어나는 상황)</li>
    </ul>
    <br>
    <h2>2. 슈퍼스칼라</h2>
    <p>파이프라이닝은 단일 파이프라인으로도 구현이 가능하지만, <strong>오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 이용</strong>한다.</p>
    <ul>
        <br>
        <li><strong>슈퍼스칼라</strong>: <strong>CPU 내부에 여러 개의 명령어 파이프라인을 두는 구조</strong></li>
        <li><strong>슈퍼스칼라 프로세서(= 슈퍼스칼라 CPU)</strong>: <strong>슈퍼스칼라 구조로 명령어 처리가 가능한 CPU</strong></li>
        <br>
        <li>슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수 있다. 오늘날 대부분의 멀티스레드 CPU는 슈퍼스칼라 구조를 사용한다.<br>
            슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례해 프로그램 처리 속도가 빨라진다. 하지만 <strong>파이프라인 위험 등의 예상치 못한 문제가 있어 실제로는 반드시 파이프라인 개수에 비례해 빨라지지 않는다.</strong></li>
        <br>
        <li><strong>슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 한다.</strong> (여러 개의 파이프라인을 이용하면 하나의 파이프라인을 사용할 때보다 데이터 위험, 제어 위험, 자원 위험을 피하기가 더욱 까다롭기 때문)</li>
    </ul>
    <br>
    <h2>3. 비순차적 명령어 처리(OoOE: Out-of-Order execution)</h2>
    <ul>
        <li><strong>순서를 바꿔 실행해도 무방한 명령어를 먼저 실행해, 명령어  파이프라인이 멈추는 것을 방지</strong>하는 기법</li>
        <li>예상치 못한 문제들로 인해 명령어는 곧바로 처리되지 못하기도 한다. <strong>만약 모든 명령어를 순차적으로만 처리한다면, 예상치 못한 상황에서 명령어 파이프라인은 멈춰 버리게 된다.</strong></li>
    </ul>

</details>

<details>
    <summary><h2>3. CISC와 RISC</h2></summary>
    <ul>
        <li><strong>CPU의 언어인 ISA</strong>와 <strong>ISA를 설계할 때 철학, 방식 (CISC/RISC)</strong></li>
        <li><strong>명령어 파이프라이닝과 슈퍼스칼라 방식을 적용하려면</strong> CPU가 인출, 해석, 실행할 때 <strong>명령어의 형태와 규칙이 파이프라인에 잘 맞도록 설계</strong>되어 있어야 한다.</li>
    </ul>
    <br>
    <h2>명령어 집합(ISA: Instruction Set Architecture)</h2>
    <ul>
        <li><strong>명령어 집합(= 명령어 집합 구조): CPU가 이해하고 실행할 수 있는 명령어들의 모음</strong></li>
        <br>
        <li>세상에는 수많은 CPU 제조사들이 있고 <strong>명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이가 있다.</strong><br>
            ex) 인텔 노트북 속의 CPU는 x86 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해한다. 실행 파일은 명령어로 이루어져 있고 서로의 컴퓨터가 이해할 수 있는 명령어가 달라, 인텔 노트북과 아이폰은 서로의 명령어를 이해할 수 없다.</li>
        <br>
        <li>ISA가 다르면 그에 따른 나비 효과로 많은 것들이 달라진다. (제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등) 그리고 이는 곧 CPU 하드웨어 설계에도 큰 영향을 미친다.<br>
            <strong>ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고 볼 수 있다.</strong></li>
    </ul>
    <br>
    <h2>CISC (Complex Instruction Set Computer)</h2>
    <ul>
        <li><strong>CISC</strong>: <strong>복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식</strong></li>
        <li>CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 <strong>가변 길이 명령어</strong>를 활용한다.</li>
    </ul>
    <br>
    <p>✔️ <strong>장점</strong></p>
    <ul>
        <li>다양하고 강력한 명령어를 활용한다. = 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다. = 메모리 공간을 절약할 수 있다.</li>
        <li>메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았다.</li>
    </ul>
    <br>
    <p>✔️ <strong>단점</strong></p>
    <ul>
        <li><strong>활용하는 명령어가 복잡하고 다양한 기능을 제공</strong>하는 탓에 <strong>명령어의 크기와 실행되기까지의 시간이 일정하지 않다.</strong></li>
        <li>복잡한 명령어 때문에 <strong>명령어 하나를 실행하는 데에 여러 클럭 주기를 필요</strong>로 한다.</li>
        <li>⭐️ <strong>명령어의 규격화가 어려워 파이프라이닝이 어렵다.</strong><br>
            명령어 파이프라인이 제대로 동작하지 않는다는 것은 현대 CPU에서 아주 치명적인 약점임! (= 높은 성능을 내기 위해 놓쳐서는 안 되는 핵심 기술이기 때문)</li>
    </ul>
    <br>
    <h2>RISC (Reduced Instruction Set Computer)</h2>
    <ul>
        <li>RISC는 CISC에 비해 <strong>명령어의 종류가 적으며, 짧고 규격화된 명령어</strong>를 사용한다. 되도록 1클럭 내외로 실행되는 명령어를 지향한다.<br>
            <strong>고정 길이 명령어</strong>를 활용한다.</li>
        <br>
        <li><strong>메모리 접근을 단순화, 최소화 하는 대신 대부분의 연산을 레지스터 간에서 처리</strong>한다. → CISC보다 <strong>범용 레지스터 개수가 많다.</strong></li>
        <li><strong>동일한 작업을 위해 필요한 명령어 개수가 CISC 보다 많아, 프로그램 전체 명령어 수가 증가한다.</strong></li>
        <br>
        <li>메모리에 직접 접근하는 명령어를 단순화해, CISC보다 <strong>주소 지정 방식의 종류가 적은 경우가 많다.</strong></li>
    </ul>

</details>
