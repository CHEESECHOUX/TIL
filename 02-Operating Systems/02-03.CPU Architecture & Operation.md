# CPU

<details>
    <summary><h2>CPU의 작동 원리</h2></summary>
    <p>CPU를 구성하는 부품들의 이름과 역할, CPU가 명령어를 실행하는 방식을 이해하자!</p>
    <br>
    <details>
        <summary><h2>1. ALU와 제어장치</h2></summary>
        <p>ALU와 제어장치가 어떤 정보를 내보내고 받아들이는지를 중심으로, 각 부품의 역할을 이해하기</p>
        <br>
        <h2>1-1. ALU</h2>
        <h3>✔️ ALU가 받아들이는 정보</h3>
        <ul>
            <li><strong>ALU</strong>: 계산하는 부품<br>
                → 피연산자와 수행할 연산이 필요</li>
            <li><strong>레지스터를 통해 피연산자</strong>를 받아들이고, <strong>제어장치로부터 수행할 연산</strong>을 알려주는 ⭐️ <strong> 제어 신호</strong>를 받아들임.
            <br>피연산자와 제어 신호로 <strong>산술 연산, 논리 연산 등 다양한 연산을 수행</strong>한다.</li>
        </ul>
        <br>
        <h3>✔️ ALU가 내보내는 정보</h3>
        <ul>
            <li>연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있다.</li>
            <li>이 <strong>결괏값</strong>은 바로 메모리에 저장되지 않고 <strong>일시적으로 레지스터에 저장</strong>된다.<br>
            → <strong>ALU가 연산할 때마다 결과를 메모리에 저장하면</strong>, 
            CPU는 메모리에 자주 접근하게 되고, <strong>메모리 왕복 과정에서 기다리는 시간이 많아져 프로그램 실행 속도가 전반적으로 늦어지게 된다.</strong></li>
        </ul>
        <br>
        <ul>
            <li>⭐️ <strong>플래그</strong>: <strong>연산 결과에 대한 추가적인 상태 정보</strong></li>
            <li><strong>플래그 레지스터</strong>: 플래그가 저장되어있는 레지스터 → 플래그 레지스터를 읽으면 연산 결과에 대한 추가적인 정보, 참고 정보를 얻을 수 있음</li>
        </ul>
        <br>
        <hr>
        <br>
        <h2>1-2. 제어장치</h2>
        <ul>
            <li>ALU가 계산을 담당하는 공장 노동자라면, 제어장치는 공장 관리자로서 누가 언제 무엇을 할지 지시하는 역할
            <br>직접 계산을 하지는 않지만, 없으면 공장은 돌아가지 못 한다.</li>
        </ul>
        <ul>
            <li>⭐️ <strong>제어장치</strong>: <strong>제어 신호를 내보내고, 명령어를 해석</strong>하는 <strong>부품</strong></li>
            <li><strong>제어신호</strong>: <strong>컴퓨터 부품들을 관리하고 작동</strong>시키기 위한 일종의 <strong>전기 신호</strong></li>
        </ul>
        <br><br>
        <h3>제어장치의 주요 역할</h3>
        <ul>
            <li><strong>명령어 해석</strong><br>메모리에서 가져온 명령어를 해석해 어떤 작업(연산, 데이터 이동 등)을 해야 할지 판단</li>
            <br>
            <li><strong>제어 신호 생성</strong><br>ALU, 레지스터, 메모리, 입출력 장치 등에 제어 신호를 보내 각 부품이 올바르게 동작하도록 지시</li>
            <br>
            <li><strong>명령어 실행 순서 제어</strong><br>프로그램 카운터를 통해 다음에 실행할 명령어의 주소를 관리하고 분기, 점프 명령이 있을 경우 실행 순서를 변경</li>
        </ul>
        <br>
        <h3>✔️ 제어장치가 받아들이는 정보</h3>
        <h4>1. 클럭 신호를 받아들인다.</h4>
        <ul>
            <li><strong>클럭(clock)</strong>: <strong>컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위</strong></li>
            <li>컴퓨터의 모든 부품이 한 클럭마다 작동하는게 아니라, 박자에 맞춰 작동하는 것! = <strong>여러 클럭에 걸쳐 실행</strong>될 수 있다.</li>
        </ul>
        <br>
        <h4>2. 해석해야 할 명령어를 받아들인다.</h4>
        <ul>
            <li><strong>명령어 레지스터로부터 명령어를 받아들이고 해석</strong>한 뒤, 제어 신호를 발생시켜 <strong>컴퓨터 부품들에 수행해야 할 내용을 알려준다.</strong></li>
        </ul>
        <br>
        <h4>3. 플래그 레지스터 속 플래그 값을 받아들인다.</h4>
        <p><strong>플래그 값(추가적인 상태 정보)</strong>을 받아들이고, 이를 참고해 제어 신호를 발생시킨다.</p>
        <br>
        <h4>4. 시스템 버스로 전달된 제어 신호를 받아들인다.</h4>
        <p><strong>제어 신호는</strong> CPU뿐만 아니라 <strong>입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다.</strong></p>
        <br><br>
        <h3>✔️ 제어 장치가 내보내는 정보</h3>
        <h4>1. CPU 외부에 전달하는 제어 신호</h4>
        <p>CPU 외부에 제어 신호를 전달한다 = <strong>제어 버스로 제어 신호를 내보낸다.</strong></p>
        <ul>
            <li><strong>메모리에 전달하는 제어 신호</strong>: 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다.</li>
            <li><strong>입출력장치에 전달하는 제어 신호</strong>: 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때</li>
        </ul>
        <br>
        <h4>2. CPU 내부에 전달하는 제어 신호</h4>
        <ul>
            <li><strong>ALU에 전달하는 제어 신호</strong>: ALU에 수행할 연산을 지시하기 위해</li>
            <li><strong>레지스터에 전달하는 제어 신호</strong>: 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해</li>
        </ul>
    </details>
    <br>
    <details>
        <summary><h2>2. 레지스터</h2></summary>
        <p>⭐️ <strong>프로그램 속 명령어와 데이터는 실행 전후로</strong> 반드시 <strong>레지스터에 저장</strong>됨.
            <br>→ 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름(= CPU 내에서 무슨 일이 일어나는지)을 파악할 수 있음</p>
        <br>
        <h2>2-1. ⭐️ 반드시 알아야 할 레지스터</h2>
        <p>상용화된 CPU 속 레지스터들은 CPU마다 이름, 크기, 종류가 매우 다양하다.</p><br><br>
        <p><strong>많은 CPU가 공통으로 포함하고 있는 여덟 개의 레지스터</strong></p>
        <h3>1. 프로그램 카운터</h3>
        <ul>
            <li>메모리에서 읽어 들일 <strong>명령어의 주소를 저장</strong></li>
            <li>프로그램 카운터 = <strong>명령어 포인터</strong> 라고도 부름.</li>
        </ul>
        <p>프로그램 카운터는 지속적으로 증가하면서 다음 명령어를 읽어 들일 준비를 함.<br>
        → CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유</p>
        <br>
        <h3>2. 명령어 레지스터</h3>
        <p><strong>해석할 명령어</strong>(= 방금 메모리에서 읽어 들인 명령어)<strong>를 저장</strong>하는 레지스터.<br>
        <strong>제어장치는 명령어 레지스터 속 명령어를 받아들이고, 해석한 뒤 제어 신호를 보냄.</strong></p>
        <br>
        <h3>3. 메모리 주소 레지스터</h3>
        <p><strong>메모리의 주소</strong>를 저장하는 레지스터.</p>
        <br>
        <h3>4. 메모리 버퍼 레지스터</h3>
        <p><strong>메모리와 주고받을 값</strong>(데이터와 명령어)을 저장하는 레지스터.<br>
        → CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 버퍼 레지스터를 거친다.</p>
        <br>
        <h3>5. 플래그 레지스터</h3>
        <p>ALU 연산 결과에 따른 플래그(= 연산 결과 또는 CPU 상태에 대한 부가적인 정보)를 저장</p>
        <br>
        <h3>6. 범용 레지스터</h3>
        <ul>
            <li>메모리 버퍼 레지스터: 데이터 버스로 주고받을 값만 저장</li>
            <li>메모리 주소 레지스터: 주소 버스로 내보낼 주소 값만 저장</li>
            <li><strong>범용 레지스터</strong>: <strong>데이터와 주소, 중간 계산 결과도 저장</strong>할 수 있음.</li>
        </ul>
        <br>
        <h3>7. 스택 포인터</h3>
        <p>주소 지정 방식에 사용될 수 있는 특별한 레지스터</p>
        <br>
        <h3>8. 베이스 레지스터</h3>
        <p>주소 지정 방식에 사용될 수 있는 특별한 레지스터</p>
        <br><br>
        <h2>2-2. 특정 레지스터를 이용한 주소 지정 방식(= 상대 주소 지정 방식)</h2><br>
        <h3>✔️ 상대 주소 지정 방식 vs 절대 주소 지정 방식</h3>
        <table border="1" cellspacing="0" cellpadding="6">
        <thead>
            <tr>
            <th>구분</th>
            <th>상대 주소 지정 (ex. PC 상대, 베이스 레지스터)</th>
            <th><strong>절대 주소 지정 (Absolute Addressing)</strong></th>
            </tr>
        </thead>
        <tbody>
            <tr>
            <td><strong>주소 지정 방법</strong></td>
            <td>명령어에 <strong>기준 레지스터 + 변위(offset)</strong> 를 기록하여 실제 주소 계산</td>
            <td>명령어에 <strong>실제 메모리 주소</strong>를 그대로 기록</td>
            </tr>
            <tr>
            <td><strong>실행 시 주소 계산</strong></td>
            <td>실행 시점에 기준 레지스터 값과 변위를 더해 유효 주소 산출</td>
            <td>추가 계산 없이 명령어에 적힌 주소 그대로 접근</td>
            </tr>
            <tr>
            <td><strong>장점</strong></td>
            <td>프로그램이 어느 메모리 위치에 올라가도 실행 가능 → <strong>위치 독립성</strong></td>
            <td>계산이 단순해 접근 속도 빠름</td>
            </tr>
            <tr>
            <td><strong>단점</strong></td>
            <td>실행 시 계산 필요 → 약간의 오버헤드</td>
            <td>프로그램이 <strong>고정된 메모리 위치에서만 실행 가능</strong></td>
            </tr>
        </tbody>
        </table>
        <br><br>
        <h3>✔️ 상대 주소 지정 방식의 종류</h3>
        <ul>
            <li><strong>스택 주소 지정 방식</strong> 기준 레지스터: 스택 포인터</li>
            <li><strong>변위 주소 지정 방식</strong> 기준 레지스터: 프로그램 카운터, 베이스 레지스터</li>
        </ul>
        <br>
        <h3>1. 스택 주소 지정 방식</h3>
        <p>스택과 스택 포인터를 이용한 주소 지정 방식.</p>
        <ul>
            <li><strong>스택 포인터</strong>: 스택의 꼭대리를 가리키는 레지스터(= 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터)</li>
            <li><strong>스택 영역</strong>: 메모리 안에 스택처럼 사용하도록 정해진 영역</li>
        </ul><br>
        <ul>
            <li><strong>기준 레지스터</strong>: <strong>스택 포인터</strong></li>
            <li>스택의 최상단을 가리키는 레지스터(SP)를 기준으로 데이터를 읽거나 저장</li>
            <li>함수 호출/복귀, 지역 변수 관리 등 <strong>후입선출(LIFO)</strong>구조에 적합</li>
        </ul>
        <br>
        <h3>2. 변위 주소 지정 방식</h3>
        <ul>
            <li><strong>공식</strong>: <strong>유효 주소 = 기준 레지스터 + 변위(offset)</strong></li><br>
            <li>명령어는 연산 코드(무엇을 할지) + 오퍼랜드(연산할 데이터 or 데이터가 있는 주소)로 이루어져 있다.<br>
            <strong>변위 주소 지정 방식을 사용하는 명령어</strong>: 연산 코드 필드 + 레지스터 필드(기준 주소를 담은 레지스터) + 오퍼랜드 필드(변위, offset)</li>
        </ul>
        <br>
        <h4>2-1. 프로그램 카운터(PC) 상대 주소 지정 방식</h4>
        <ul>
            <li><strong>기준 레지스터: 프로그램 카운터</strong></li>
            <li><strong>현재 실행 중인 명령어의 다음 주소(PC)를 기준으로 변위를 더해 분기/점프</strong></li>
            <li>if문, loop 등 <strong>분기(branch)</strong> 명령어 주로 사용</li>
        </ul>
        <br>
        <h4>2-2. 베이스 레지스터 주소 지정 방식</h4>
        <p><strong>오퍼랜드</strong>와 <strong>베이스 레지스터</strong>의 값을 더해 유효 주소를 얻는 방식</p>
        <ul>
            <li><strong>베이스 레지스터</strong>: <strong>기준 주소</strong></li>
            <li><strong>오퍼랜드</strong>: <strong>기준 주소로부터 떨어진 거리</strong>(offset)</li>
        </ul>
        <br>
        <ul>
            <li><strong>기준 레지스터: 베이스 레지스터</strong></li>
            <li><strong>프로그램 시작 주소를 베이스로 설정 후 변위를 더해 데이터 접근</strong></li>
            <li>운영체제의 메모리 재배치나 <strong>위치 독립적 코드</strong>작성에 유리</li>
        </ul>
        <br>
        <h3>상대 주소 지정 방식을 쓰는 이유</h3>
        <ol>
            <li><strong>위치 독립성 확보</strong><br>
                프로그램이 메모리 어디에 적재되더라도 현재 명령어가 저장된 위치(프로그램 카운터)를 기준으로 분기할 수 있다.<br>
            </li><br>
            <li><strong>코드 크기 절약</strong><br>
                분기할 절대 주소를 저장하지 않고 PC에서의 상대 변위(offset)만 저장하면 되므로, 명령어 길이가 짧아지고 코드 크기를 줄일 수 있다.
            </li><br>
            <li><strong>주소 계산 효율</strong><br>
                하드웨어가 PC + 변위를 한 번의 연산으로 처리하므로 분기, 점프, 명령 실행 속도가 빠르다.
            </li><br>
            <li><strong>링킹/로딩 편리</strong><br>
                컴파일, 링킹 시점에 정확한 절대 주소를 몰라도, 실행 시점에 현재 PC 기준으로 계산하므로 <strong>재컴파일 없이 재배치 가능</strong>
            </li>
        </ol>
        <hr>
        <br>
    </details>
    <br>
    <details>
        <summary><h2>3. 명령어 사이클과 인터럽트</h2></summary>
        <p>CPU가 하나의 명령어를 처리하는 흐름인 명령어 사이클과 그 흐름을 방해하는 인터럽트를 이해하자!</p>
        <br>
        <h2>명령어 사이클</h2>
        <p>프로그램은 수많은 명령어로 이루어져있다. CPU는 이 명령어들을 하나씩 실행한다.<br>
        이때 <strong>프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행</strong>된다. 이 주기를 <strong>명령어 사이클</strong>이라한다.</p>
        <br>
        <ul>
            <li><strong>명령어 사이클: CPU가 하나의 명령어를 처리하는 흐름</strong></li>
            <li><strong>인출, 실행, 간접, 인터럽트 시이클로 구성</strong> 되어 있다.</li>
        </ul>
        <br>
        <ol>
            <li><strong>인출 사이클</strong>: <strong>메모리에 있는 명령어를 CPU로 가지고 오는 단계</strong></li>
            <li><strong>실행 사이클</strong>: <strong>CPU로 가져온 명령어를 실행하는 단계</strong><br>
            (= 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계)
            </li>
            <li><strong>간접 사이클</strong>: <strong>간접 주소 지정 방식</strong>의 명령어를 실행할 때 <strong>실행 사이클 전에 필요한 추가 단계</strong><br>
            명령어에 있는 주소가 실제 데이터가 아니라 또 다른 주소를 가리킬 경우, CPU가 그 실제 오퍼랜드 주소를 메모리에서 읽어오는 과정.
            </li>
        </ol>
        <br>
        <h2>인터럽트</h2>
        <p>인터럽트: <strong>CPU의 작업을 방해하는 신호</strong></p>
        <br>
        <h3>1. 동기 인터럽트 (= 예외)</h3>
        <p><strong>CPU에 의해 발생하는 인터럽트</strong></p>
        <p>CPU가 <strong>명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때</strong> (= 프로그래밍상의 오류) 발생하는 인터럽트</p>
        <br>
        <h3>2. 비동기 인터럽트(= 하드웨어 인터럽트)</h3>
        <p><strong>입출력장치에 의해 발생하는 인터럽트</strong></p>
        <p>CPU가 프린터와 같은 <strong>입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)을 보낸다.</strong><br>
        (= CPU는 주기적으로 프린트 완료 여부를 확인할 필요가 없고, 프린트 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다.)</p>
        <br>
        <h3>비동기 인터럽트(= 하드웨어 인터럽트) 처리 순서</h3>
        <ol style="list-style-type: decimal;">
            <li>입출력장치는 CPU에 <strong>인터럽트 요청 신호</strong>를 보낸다.</li>
            <li>CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.</li>
            <li>CPU는 인터럽트 요청을 확인하고 <strong>인터럽트 플래그</strong>를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.</li>
            <li>인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.</li>
            <li>CPU는 <strong>인터럽트 벡터</strong>를 참조해 <strong>인터럽트 서비스 루틴</strong>을 실행한다.</li>
            <li>인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구해 실행한다.</li>
        </ol>
        <br>
        <p>* 다시 한 번 정리!</p>
        <ul>
            <li><strong>인터럽트 요청 신호</strong>: CPU의 작업을 방해하는 인터럽트에 대한 요청</li>
            <li><strong>인터럽트 플래그</strong>: 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트</li>
            <li><strong>인터럽트 벡터</strong>: 인터럽트 서비스 루틴의 시작 주소를 포함하는 각기 다른 인터럽트 서비스 루틴의 식별 정보</li>
            <li><strong>인터럽트 서비스 루틴</strong>: 인터럽트를 처리하는 프로그램</li>
        </ul>
        <br>
        <p><strong>CPU가 인터럽트를 처리한다 = 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다</strong></p>
        </details>

</details>
