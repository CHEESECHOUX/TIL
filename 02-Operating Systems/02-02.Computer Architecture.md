# 컴퓨터 구조

<details>
    <summary><h3>컴퓨터 구조</h3></summary>
    <p>컴퓨터 구조를 이해하면 <strong>성능/용량/비용을 고려</strong>하며 개발할 수 있다.</p>
    <ul>
        <li><strong>컴퓨터가 이해하는 정보</strong>: 데이터, 명령어</li>
        <li><strong>컴퓨터의 네가지 핵심 부품</strong>: CPU, 메모리, 보조기억장치, 입출력장치</li>
    </ul>
    <br>
    <h2>메모리</h2>
    <ul>
        <li>메모리는 <strong>현재 실행되는 프로그램의 명령어와 데이터를 저장</strong>한다.</li>
        <li>메모리에 저장된 값의 위치는 <strong>주소</strong>로 알 수 있다.</li>
        <li><strong>프로그램이 실행되기 위해서는 반드시 메모리에 저장</strong>되어 있어야 한다.<br>(= CPU가 프로그램을 직접 실행할 수 있는 곳은 메인 메모리(RAM) 뿐이다.)</li>
    </ul>
    <br>
    <h2>CPU</h2>
    <p><strong>메모리에 저장</strong>된 <strong>명령어를 읽어 들이고, 해석하고, 실행</strong>하는 장치</p>
    <br>
    <h3>CPU 내부 구성 요소</h3>
    <ul>
        <li><strong>산술논리연산장치 (ALU: Arithmetic Logic Unit)</strong><br/>계산기. 컴퓨터 내부에서 수행되는 대부분의 계산을 도맡아 수행함.</li>
        <li><strong>레지스터</strong><br/>CPU 내부의 작은 임시 저장 장치.<br/>프로그램을 실행하는데 필요한 값들을 임시로 저장 </li>
        <li><strong>제어장치(CU: Control Unit)</strong><br/>제어 신호라는 전기 신호를 내보내고 명령어를 해석하는 장치 <br/>제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호 </li>
    </ul>
    <br>
    <p>CPU가 메모리에 저장된 값을 읽고 싶을 땐 메모리를 향해 <strong>메모리 읽기</strong>라는 제어 신호를 보낸다.<br/>CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 <strong>메모리 쓰기</strong>라는 제어 신호를 보낸다.</p>
    <br>
    <h2>보조기억장치</h2>
    <p><strong>메모리보다 크기가 크고 전원이 꺼져도 저장된 내용을 잃지 않는</strong> 메모리를 보조할 저장 장치<br/>ex) 하드 디스크, SSD, USB 메모리, DVD, CD</p>
    <ul>
        <li>메모리의 단점: 가격이 비싸 저장 용량이 적음. 전원이 꺼지면 저장된 내용을 잃는다.</li>
    </ul>
    <br>
    <h2>입출력장치</h2>
    <p>마이크, 스피커, 프린터, 마우스, 키보드처럼 <strong>컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치</strong></p>
    <br>
    <h2>메인보드와 시스템 버스</h2>
    <ul>
        <li>메인보드 : 여러 컴퓨터 부품을 연결해줌</li>
        <li>버스 : 메인보드에 연결된 부품들이 서로 정보를 주고 받을 수 있는 통로</li>
        <li>시스템 버스 : 컴퓨터의 네 가지 핵심 부품을 연결하는 가장 중요한 버스(= 통로)</li>
    </ul>
    </details>
    <br>
    <details>
    <summary><h3>데이터</h3></summary>
    <h2>정보 단위</h2>
    <p>컴퓨터는 0 또는 1밖에 이해하지 못함 </p>
    <ul>
        <li>비트 : 0과 1을 나타내는 가장 작은 정보 단위</li>
        <br>
        <li>바이트: 여덟 개의 비트를 묶은 단위</li>
        <li>킬로바이트: 1바이트 1,000개를 묶은 단위</li>
        <li>메가바이트: 1킬로바이트 1,000개를 묶은 단위</li>
        <li>기가바이트: 1메가바이트 1,000개를 묶은 단위</li>
        <li>테라바이트: 1기가바이트 1,000개를 묶은 단위 </li>
        <br>
        <li>워드: CPU가 한 번에 처리할 수 있는 데이터 크기</li>
    </ul>
    <br>
    <h2>0과 1로 문자를 표현하는 방법</h2>
    <p>아스키 코드, 유니코드 등은 컴퓨터가 이해할 수 있는 0과 1로 다양한 문자를 표현하는 방법</p>
    <ul>
        <li><strong>문자 집합</strong>: 컴퓨터가 인식하고 표현할 수 있는 문자의 모음.</li>
    </ul>
    <br><p>문자 집합에 속한 문자를 인코딩해 0과 1로 표현할 수 있다.</p>
    <br>
    <h3>아스키 코드</h3>
    <p>아스키는 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함함.</p>
    <ul>
        <li>장점: 매우 간단하게 인코딩 된다.</li>
        <li>단점: 한글을 표현할 수 없다. (영어권 외의 나라들은 자신들의 언어를 표현할 수 없음)\</li>
    </ul>
    <p>아스키 문자 집합에 속한 문자들은 <strong>7비트로 표현</strong>하기에, <strong>128개보다 많은 문자를 표현하지 못함</strong>. <br>아스키 코드에 1비트를 추가한 8비트의 확장 아스키가 등장하기도 했지만, 표현 가능한 문자의 수는 256개여서 턱없이 부족함.</p>
    <br>
    <h3>EUC-KR</h3>
    <p>한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식.</p>
    <p>알파벳을 쭉 이어 쓰면 단어가 되는 영어와는 달리, 한글은 각 음절 하나하나가 초성, 중성, 종성의 조합으로 이루어져 있음.</p>
    <br>
    <h4>한글 인코딩 방식</h4>
    <ul>
        <li><strong>완성형 인코딩 방식</strong>: 초성, 중성, 종성의 조합으로 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식 </li>
        <li><strong>조합형 인코딩 방식</strong>:초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당해 그것들의 조합으로 하나의 글자코드를 완성하는 인코딩 방식</li>
    </ul>
    <br>
    <h2>유니코드와 UTF-8</h2>
    <p>언어별로 인코딩을 해야 한다면 다국어를 지원하는 프로그램을 만들 때 각 나라 언어의 인코딩을 모두 알아야하는 번거로움이 있음.</p>
    <ul>
        <li><strong>유니코드</strong>: <strong>여러 나라의 문자들</strong>을 광범위하게 표현할 수 있는 <strong>통일된 문자 집합</strong>. UTF-8, UTF-16, UTF-32 는 유니코드 문자의 인코딩 방식 </li>
    </ul>
    </details>
    <br>
    <details>   
    <summary><h3>명령어</h3></summary>
    <p>C, C++, Java, Python과 같은 <strong>프로그래밍 언어로 만든 소스 코드</strong>는 컴퓨터 내부에서 <strong>명령어로 변환</strong>된다.</p>
    <br>
    <h2>고급언어, 저급언어</h2>
    <ul>
        <li>고급 언어: <strong>사람</strong>이 이해하고 작성하기 쉽게 만들어진 언어</li>
        <li>저급 언어: <strong>컴퓨터</strong>가 직접 이해하고 실행할 수 있는 언어 </li>
    </ul>
    <br>
    <p><strong>컴퓨터가 이해하고 실행할 수 있는 언어는</strong> 오직 <strong>저급 언어!</strong>
        <br>→<strong>고급 언어로 작성된 소스 코드가 실행</strong>되려면 반드시 <strong>저급 언어(= 명령어)로 변환</strong> 되어야 한다.</p>
    <br>
    <h3>저급언어</h3>
    <ul>
        <li><strong>기계어</strong>: <strong>0과 1로 이루어진 명령어</strong> 모음</li>
        <li><strong>어셈블리어</strong>: 0과 1로 표현된 <strong>명령어(기계어)를 읽기 편한 형태로 번역</strong>한 언어 </li>
    </ul>
    <p>하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 개발자는 어셈블리어를 많이 이용함.</p>
    <br>
    <h2>컴파일 언어와 인터프리터 언어</h2>
    <p><strong>고급언어가 저급언어로 변환되는 방식</strong>에는 컴파일 방식, 인터프리트 방식이 있다.</p>
    <br>
    <h3>컴파일 언어</h3>
    <p><strong>컴파일 방식으로 작동</strong>하는 프로그래밍 <strong>고급 언어</strong>.
        <br>대표적인 컴파일 언어는 C</p>
    <ul>
        <li><strong>컴파일</strong>: 컴파일 언어로 작성된 <strong>소스 코드 전체가 저급 언어로 변환</strong>되는 과정</li>
        <li><strong>컴파일러</strong>: <strong>컴파일을 수행해 주는 도구</strong></li>
    </ul>
    <p>컴파일러는 개발자가 작성한 소스 코드 전체를 훑어보며 실행 가능한지 저급 언어로 컴파일한다. 이때 <strong>오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패</strong>한다.</p>
    <br>
    <ul>
        <li><strong>목적 코드</strong>: <strong>컴파일러를 통해 저급 언어로 변환된 코드</strong></li>
    </ul>
    <br>
    <h3>인터프리터 언어</h3>
    <p>인터프리터에 의해 <strong>소스 코드가 한 줄씩 실행</strong>되는 <strong>고급 언어</strong>.<br>대표적으로 Python</p>
    <ul>
        <li>인터프리터: 소스 코드를 한 줄씩 저급 언어로 변환해 실행해 주는 도구 </li>
    </ul>
    <br>
    <p>인터프리터 언어는 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다. </p>
    <p><strong>일반적으로 인터프리터 언어는 컴파일 언어보다 느리다.</strong>
        <br/>컴파일을 통해 나온 결과물(= 목적 코드)은 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문이다. </p>
    <br>
    <br>
    <p><strong>하나의 프로그래밍 언어가 반드시 둘 중 하나의 방식으로만 작동한다고 생각하는 것은 오개념</strong>이다!</p>
    <p>대표적인 인터프리터 언어 Python도 컴파일을 하지 않는 것은 아니고, Java는 저급 언어가 되는 과정에서 컴파일과 인터프리터를 동시에 수행한다.</p>
    <p><strong>고급 언어가 저급 언어로 변환되는 대표적인 방법에 컴파일, 인터프리트 방식이 있다. 정도로만 이해</strong>하쟈!</p>
    <br>
    <h2>목적 파일 vs 실행 파일</h2>
    <ul>
        <li><strong>목적 파일</strong>: 목적 코드로 이루어진 파일</li>
        <li><strong>실행 파일</strong>: 실행 코드로 이루어진 파일</li>
    </ul>
    <ul>
        <li><strong>링킹</strong>: <strong>컴파일된 목적 파일들을 연결해 실행 파일을 만드는 단계</strong><br/>함수나 변수 참조 같은 심볼을 실제 정의와 연결하고, 메모리 주소를 재배치하는 작업을 수행함. 결과적으로 운영체제가 실행할 수 있는 형태로 프로그램이 완성된다.</li>
    </ul>
    <br>
    <br>
    <h2>명령어의 구조</h2>
    <p>명령어는 <strong>연산 코드와 오퍼랜드로 구성</strong>되어 있다. </p>
    <ul>
        <li><strong>연산 코드</strong>: <strong>명령어가 수행할 연산</strong> (연산자)</li>
        <li><strong>오퍼랜드</strong>: <strong>연산에 사용할 데이터 또는 데이터가 저장된 위치</strong> (피연산자)</li>
    </ul>
    <br>
    <h3>연산 코드 유형</h3>
    <ul>
        <li>데이터 전송</li>
        <li>산술/논리 연산</li>
        <li>제어 흐름 변경</li>
        <li>입출력 제어</li>
    </ul>
    <br>
    <h2>주소 지정 방식</h2>
    <p>오퍼랜드 필드에 저장된 위치를 명시할 때 <strong>연산에 사용할 데이터 위치를 찾는 방법.</strong></p>
    <ul>
        <li><strong>유효 주소</strong>: 연산의 대상이 되는 데이터가 저장된 위치</li>
    </ul>
    <br>
    <h3>대표적인 주소 지정 방식</h3>
    <ul>
        <li>즉시 주소 지정 방식: 연산에 사용할 데이터</li>
        <li>직접 주소 지정 방식: 유효 주소(메모리 주소)</li>
        <li>간접 주소 지정 방식: 유효 주소의 주소</li>
        <li>레지스터 주소 지정 방식: 유효 주소(레지스터 이름)</li>
        <li>레지스터 간접 주소 지정 방식: 유효 주소를 저장한 레지스터</li>
    </ul>
    <p>+ 주소 지정 방식 사용하는 이유?</p>
</details>
