# 시스템 아키텍처

<details>
    <summary><h3>3계층 구조 (3-Tier Architecture)</h3></summary>
    <ul>
        <li><strong>3계층 구조란?</strong></li>
        플랫폼을 세 가지 계층으로 나누어 논리적 또는 물리적으로 분리하여 구축 및 운영하는 아키텍처
        <br><br>
        예를 들어 웹 서비스를 운영할 때, 서버 한 대에 모든 기능을 통합하는 대신<br> 
        <strong>프레젠테이션 계층, 애플리케이션 계층, 데이터 계층</strong><br>
        으로 분리해 각각 독립적으로 관리한다.
        <br><br>
        3계층 외에도 2계층, 4계층 등 다양한 구조로 나눌 수 있으며, 이를 <strong>다층 구조(Multi-tier Architecture)</strong>라고 한다.
        <br><br>
        <li><strong>프레젠테이션 계층</strong></li>
        사용자와 직접 상호작용하는 계층. UI와 사용자 요청 전달 및 결과 표시<br>
        ex) React, HTML/CSS, Android 앱
        <li><strong>애플리케이션 계층</strong></li>
        비즈니스 로직 처리, 사용자 요청을 처리, DB와 연동
        ex) Python, Node.js, Java 서버
        <li><strong>데이터 계층</strong></li>
        데이터 저장, 조회, 수정 등의 기능을 담당<br>
        ex) MySQL, PostgreSQL, MongoDB

<br><br>

<li>
    <em>※ 추가) 2-tier, n-tier 구조와의 차이</em>
</li>

    </ul>

</details>

<br><br>

# ✔️ Tech-Interview

<details>
    <summary><h3>웹 환경 아키텍처</h3></summary>
    <ul>
        <li>
            <p><strong>Q1. 다양한 클라이언트 디바이스(웹, 모바일, 태블릿)에서 서버를 호출할 때, 일반적인 3-Tier 환경에서 동작하는 전반적인 프로세스를 설명해주세요.</strong></p>
            <p>A. 
                사용자는 프레젠테이션 계층(웹 브라우저, 모바일 앱 등)을 통해 요청을 보냅니다. 이 요청은 애플리케이션 계층(Web 서버, API 서버 등)으로 전달되어 비즈니스 로직이 처리되고, 필요한 경우 데이터 계층(DB 서버)에서 데이터를 읽거나 저장합니다. <br>
                처리된 결과는 다시 애플리케이션 계층을 통해 프레젠테이션 계층으로 전달되어 사용자에게 응답됩니다.
                <br><br>
                + DNS, L7의 역할, LB 등의 역할 추가
                + 방화벽, CDN, DB의 리플리케이션 정도 설명 추가
            </p>
        </li>
        <br>
        <li>
        <p><strong>Q2. 그 중 특정 디바이스 혹은 메뉴의 트래픽이 월등히 높아 서버에 부하가 많이 걸릴 경우, 아키텍처를 어떻게 구성 또는 변경해야 할까요?</strong></p>
        <p>질문의 의도: 점진적인 구조적 개선을 고민해보았는지, 데이터 및 트래픽의 부하 분산에 대해서 알고 있는지 물어보기 위함</p>
        <p>A. 병목 지점을 파악해서 서버를 늘리거나 DB의 수행 속도를 개선해야 한다. 정도의 답변은 아쉬움.
        </p>
        </li>

    </ul>

</details>

<br>

## 분산 시스템

<details>
    <summary><h3>비동기 메시지 처리(Message Queue)</h3></summary>
    <blockquote>
        <strong>Q.</strong> 온라인 사이트에서 특정 상품의 구매 이력이 있는 회원에게 간단한 설문을 요청한 후, 제출하면 자동으로 1만원 상당의 스타벅스 기프티콘을 주는 이벤트를 한다고 가정한다. 
        하루 동안 진행되고 판매사와 계약 관계 등을 고려해 정시에 오픈 후 목표한 기프티콘이 소진되면 이벤트를 종료한다고 할 때 어떤 방식의 아키텍처를 고려해야 할까?
    </blockquote>
    <br>
    <p><strong>→ 당일 이벤트이기 때문에 몇 분 이내에 접속이 폭주할 것!</strong></p>
    <br>
    <h3>1. 트래픽 처리</h3>
    <strong>문제점</strong>
    <ul>
        <li>구매/설문 페이지에 급격한 접속 증가</li>
        <li>기프티콘 전송 로직의 병목 가능성</li>
        <li>회원 정보 조회 부하로 전체 로그인/회원가입까지 영향</li>
    </ul>
    <br>
    <strong>해결 방안</strong>
    <ol>
        <li><strong>비동기 처리 구조 도입</strong><br>
            - HTTP 200 응답만 빠르게 반환(응모 성공 메시지)<br>
            - 설문/응모 데이터는 MQ에 저장하고 별도 처리</li><br>
        <li><strong>이벤트 응답 전용 테이블 분리</strong><br>
            - 응모 데이터(회원 ID, 설문 결과, 응모 시간 등 이벤트 참여 데이터)만 저장해 DB I/O 최소화<br>
            (= 다른 테이블에는 접근하거나 영향을 주지 않도록)
        </li><br>
        <li><strong>트랜잭션 분리</strong><br>
            - MQ를 통해 회원 인증 / 재고 차감 / 기프티콘 전송을 분리 처리</li><br>
    </ol>
    <h3>2. 재고 관리</h3>
    <strong>문제점</strong>
    <ul>
        <li>RDB에서 UPDATE로 수량 차감 시 동시성 병목</li>
        <li>재고 수량 처리 중 데이터 정합성 오류 위험</li>
    </ul>
    <br>
    <strong>해결 방안</strong>
    <h4>Redis 기반 재고 관리</h4>
    <ul>
        <li><strong>레디스는 싱글 스레드 기반</strong>으로 여러 클라이언트 요청을 동시에 처리하지 않고, <strong>하나의 스레드로 순차적으로 처리</strong>한다.</li>
        <li>decr 같은 원자 연산 사용<br>
            (= 동시성 문제 없이 수량을 안전하게 줄이기 위해 사용하는 명령)</li>
        <li>Pub/Sub or 메시지 큐로 이벤트 브로드캐스팅 가능</li>
        <li>TTL 설정으로 이벤트 자동 종료 가능</li>
    </ul>
    <br>
    <ul>
        <li><strong>Redis는 인메모리 기반</strong>으로 <strong>데이터 유실 가능성</strong>이 있다.<br>이를 보완하려면 <strong>클러스터 구성, 백업 정책(AOF/RDB 설정), 디스크 저장 MQ 사용</strong>(RabbitMQ, Kafka는 자체적으로 디스크에 저장)</li>
        <br>
        <li><strong>총 재고 수/지급 수량은 RDBMS에 별도 기록</strong></li>
        <li>안전 재고 확보(ex: 총 100개 중 10개는 오차방지용)</li>
    </ul>
    <br>
    * 이벤트 브로드캐스팅: 시스템에서 어떤 이벤트가 발생했을 때, 여러 컴포넌트(또는 서비스)에게 동시에 그 이벤트를 알려주는 방식.<br>
    설문 제출 후 재고 수량 감소, 응모 DB 기록, 기프티콘 발송 작업이 동시에 필요할 때 <strong>"설문 제출 완료"라는 이벤트를 브로드캐스팅</strong>하면 각각의 처리 담당 서비스가 해당 이벤트를 구독하고 자기 역할을 수행할 수 있음.<br>
    <br><br>
    <h3>3. 메시지 큐(MQ) 도입 이유</h3>
    <p>MQ(Message Queue): 시스템끼리 데이터를 주고받을 때, 바로 처리하지 않고 중간에서 메시지를 안전하게 저장하고 전달해주는 중간 관리자</p>
    <br>
    <strong>구성 요소</strong><br>
    - Producer: 메시지를 보내는 쪽 (ex: 주문 생성 서비스)<br>
    - Queue(MQ): 메시지를 줄 세워 보관하는 공간<br>
    - Consumer: 메시지를 받아서 처리하는 쪽(ex: 결제 처리 서비스)<br>
    <br>
    <strong>왜 필요한가?</strong><br>
    1. 비동기 처리<br>
    Producer가 메시지를 보내고 기다리지 않고 다른 작업을 할 수 있음<br>
    <br>
    2. 시스템 간 결합도 낮춤<br>
    Producer와 Consumer가 직접 연결되지 않아도 됨<br>
    <br>
    3. 트래픽 폭주에 견딜 수 있음<br>
    Queue에 일단 쌓아두고, Consumer가 하나씩 처리<br>
    <br>
    * MQ가 없으면?<br>
    - 모든 처리를 API 서버가 동기적으로 처리 → 응답 지연 / 타임아웃 / 서버 다운<br>
    - 기프티콘 중복 지급 가능성이 높아짐<br>
    - 트래픽에 따라 DB나 외부 API 폭주로 실패할 가능성이 높아짐<br>
    <br>
    <br>
    <p><strong>전체 구조는 비동기 시스템이고, 그 안에서 분산 전송으로 성능을 높임.</strong></p>
    <br>
    <h3>MQ 처리 흐름 예시</h3>
    <ol>
        <li>Producer가 MQ에 메시지를 보냄 → 즉시 반환됨(비동기)</li>
        <li>MQ는 해당 메시지를 큐에 쌓음</li>
        <li>Consumer A, B, C 중 하나가 메시지를 꺼내 처리 → 동시에 여러 Consumer가 처리 (분산)</li>
    </ol>
    <br>
    <h3>설문 이벤트 처리 흐름 예시</h3>
    <ol>
        <li>클라이언트가 설문 제출</li>
        <li>응답 200 반환 + 메시지 큐에 응모 데이터 적재</li>
        <li>Consumer가 큐의 메시지를 꺼내 다음 작업 처리
        <ul>
            <li>Reids 재고 차감</li>
            <li>전화번호 조회(리플리케이션 DB 활용)</li>
            <li>기프티콘 발송(SMS/알림톡)</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>메시지 큐를 이용한 비동기 처리의 특징</h3>
    <ul>
        <li>비동기성: 클라이언트 응답과 백엔드 처리를 분리<br>(= 비동기 메시지를 사용해 다른 응용프로그램 사이에 데이터를 송수신)</li>
        <li>확장성: Consumer 인스턴스 수평 확장 가능<br>(= Consumer 인스턴스 여러 개 띄우기), 시스템을 기능 단위로 분리하고 독립적으로 확장할 수 있어, 모듈 구성과 유지보수가 용이함.</li>
        <li>신뢰성: 실패 시 재처리, 디스크 기반 저장</li>
        <li>관심사의 분리: 각 역할을 독립 모듈로 관리 가능</li>
        <li>트래픽 완화: 처리 속도와 관계없이 요청을 큐에 누적</li>
    </ul>
    <br>
    <br>
    <h2>🚨 비동기 메시지 처리 문제점</h2>
    <h3>1. 메시지 유실 위험</h3>
    <ul>
        <li>메시지가 큐에 들어가기 전에 서버가 죽으면 데이터 손실</li>
        <li>MQ 자체에 장애가 났을때, 영속성 설정이 없으면 메시지 사라질 수 있음</li>
    </ul>
    <br>
    <p><strong>해결 방법</strong></p>
    <ol>
        <li>Persistent 설정
        <ul>
            <li>메시지를 디스크에 저장(persistent) 하겠다고 설정</li>
        </ul>
        </li>
        <li>Acknowledgement(Ack)
        <ul>
            <li>Consumer가 메시지를 정상적으로 처리했다는 응답을 MQ에 보내야 메시지가 삭제됨</li>
            <li>Ack 응답이 없으면 MQ는 처리 안 되었다고 생각하고 다시 전송</li>
        </ul>
        </li>
        <li>디스크 저장 기반 MQ 사용
        <ul>
            <li>Redis 같은 인메모리 큐는 메시지를 메모리에만 저장하므로 유실 위험이 큼.</li>
            <li>Kafka, RabbitMQ는 메시지를 디스크에 저장하는 기능이 기본으로 있음</li>
            <li>=&gt; 장애가 나더라도 하드 디스크에 남아 있는 메시지를 다시 꺼내서 처리 가능</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>2. 중복 처리(Duplication)</h3>
    <ul>
        <li>메시지를 한 번 처리했는데, Consumer가 ack 응답을 못 보냈을 경우 → MQ는 다시 전송</li>
        <li>그 결과 같은 작업이 두 번 실행될 수 있음</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    Idempotent 처리(중복을 허용하지 않는 로직) 설계<br>
    <ul></ul>
        <li>메시지마다 message_id 또는 uuid 부여</li>
        <li>DB나 Redis에 message_id 처리 여부 기록</li>
        <li>같은 ID가 이미 처리된 경우 무시</li>
    </ul>
    <br>
    <h3>3. 처리 순서 보장 어려움</h3>
    <ul>
        <li>MQ는 메시지를 빠르게 처리하기 위해 여러 Consumer에게 메시지를 분산 전송</li>
        <li>이때 네트워크 지연, 처리 속도 차이로 인해 메시지가 도착하거나 처리되는 순서가 달라질 수 있음</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    <ol>
        <li>Kafka 파티션 단위 처리
        <ul>
            <li>메시지를 보낼 때 특정 기준으로(ex: user_id, order_id) 같은 파티션으로 보내도록 설정</li>
            <li>동일한 사용자, 주문 ID 별로 순서가 보장된 채 처리됨</li>
            <li>Kafka는 메시지를 토픽(topic) 안의 여러 파티션에 나눠 저장함.</li>
            <li>같은 파티션 안에서는 메시지 순서가 보장됨(FIFO)</li>
            <li>메시지 순서를 보장하고 싶은 기준(ex: 사용자, 주문 등) 단위로 컨트롤 가능</li>
        </ul>
        </li>
        <li>큐를 분리해서 순서 보장
        <ul>
            <li>순서가 중요한 작업과 그렇지 않은 작업을 나눠서 처리</li>
            <li>=&gt; 순서가 중요한 메시지만 따로 큐를 만들어서 순차 처리</li>
            <li>순서 보장 + 중요하지 않은 작업은 병렬로 빠르게 처리 가능</li>
            <li>또는 고객/주문 단위로 개별 큐를 운용</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>4. 오류 추적 및 디버깅 어려움</h3>
    <ul>
        <li>처리 흐름이 비동기 + 분산되어 있어 문제 발생 시 흐름 추적 어려움</li>
        <li>Producer(메시지를 만드는 쪽 ex: 사용자의 설문 응답을 MQ에 넣는 서버), MQ(메시지를 받아 저장하고 전달하는 중간 시스템), Consumer(메시지를 받아서 실제 처리 담당 ex: 재고 차감, 기프티콘 발송 등)가 각각 로그를 남기므로 디버깅 어려움</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    <ol>
        <li>추적 ID(Correlation ID)
        <ul>
            <li>하나의 요청 흐름을 추적할 수 있도록 공통된 ID를 부여</li>
        </ul>
        </li>
        <li>분산 트레이싱 도구(Jaeger, Zipkin 등)
        <ul>
            <li>요청 흐름이 여러 시스템을 거칠 때, 그 경로를 시각적으로 추적할 수 있는 트레이싱 시스템</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>5. 복잡도 증가</h3>
    <ul>
        <li>큐 설정, 메시지 포맷, 에러 처리 로직 등 시스템이 복잡해짐</li>
        <li>운영자가 큐를 실수로 삭제하거나, 메세지의 구조를 Producer와 Consumer가 제대로 맞추지 않으면 문제가 생기고, 장애가 더 커질 수 있음</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    <ul>
        <li>1. 표준화된 메시지 스키마 정의 및 검증(ex: JSON Schema, Avro 등)</li>
        <li>2. 큐 운영 모니터링 시스템 구축(ex: RabbitMQ UI, Kafka Manager, Grafana 등)</li>
    </ul>
    <br>
    <h3>6. 트랜잭션 일관성 어려움</h3>
    <ul>
        <li>DB 저장과 MQ 전송을 한 번에 묶는 분산 트랜잭션이 어려움</li>
        <li>둘 중 하나만 성공하면 데이터 정합성 깨짐</li>
    </ul>
    <p><strong>해결 방법: Outbox 패턴, 이중확인 로직, 보상 트랜잭션</strong></p>
    <br>
    <h4>1. Outbox 패턴</h4>
    DB에 메시지를 같이 저장하고, 나중에 큐로 전송하는 방식<br><br>
    <ul>
        <li>트랜잭션 안에서 응답 데이터 저장, Outbox 테이블에 메시지도 함께 저장</li>
        <li>별도 프로세스(이벤트 퍼블리셔)가 Outbox 테이블을 읽어서 MQ로 전송</li>
        <li>전송 완료된 메시지는 Outbox에서 삭제하거나 상태 변경</li>
        <br>
        <li>장점: DB 저장과 메시지 저장이 하나의 트랜잭션으로 묶임 → 정합성 보장 + 유실 방지</li>
    </ul>
    <br>
    <h4>2. 이중확인 로직</h4>
    DB 저장과 MQ 전송이 따로라면, 한 쪽이 실패했을 때 다시 확인해서 재처리<br><br>
    <ul>
        <li>DB 저장 성공 & MQ 전송 실패: 배치나 백그라운드 워커가 미전송 데이터 재전송</li>
        <li>DB 저장 실패 & MQ 전송 성공: 메시지에 포함된 ID로 DB 저장 여부 재확인 → 실패 시 롤백 또는 보상</li>
    </ul>
    <br>
    <h4>3. 보상 트랜잭션</h4>
    <ul>
        <li>한 쪽만 성공해서 정합성이 깨졌다면, 후속 작업으로 실패 이전 상태로 되돌리자</li>
        <li>ex) 상품 주문 메시지는 전송 되었지만 결제 실패 등의 이유로 DB 저장 실패 시, 이미 감소된 재고를 다시 복원</li>
    </ul>
    <br>

</details>
