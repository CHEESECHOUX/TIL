## 운영체제

## ✔️ Tech-Interview

<details>
    <summary><h3>
        블로킹 vs 논블로킹, 동기 vs 비동기
    </h3></summary>
    <ul>
        <li>
            <p><strong>
                Q. 블로킹과 논블로킹, 동기와 비동기의 차이를 설명하고 각 개념을 적용할 수 있는 구체적인 사례를 설명해보세요.
            </strong></p>
            <p> 💡 블로킹/논블로킹, 동기/비동기의 개념은 서로 조합되어 사용될 수 있다.
                실무에서 성능 최적화, UX 개선에 자주 사용됨.<br>
                <br>
                <strong>A. 개념 정리</strong><br><br>
                <strong>1. 블로킹(Blocking) vs 논블로킹(Non-blocking): 제어권</strong><br>
                호출되는 함수가 결과 나올 때까지 대기하는가? 제어권을 넘겨주고 바로 다른 일을 하러 가는가?<br><br>
                - <strong>블로킹:</strong> 호출된 함수가 작업이 끝날 때 까지 제어권을 반환하지 않고 기다리는 방식<br>
                - <strong>논블로킹:</strong> 작업을 요청하면 바로 제어권을 돌려주고, 나중에 콜백이나 이벤트로 결과를 받는 방식. 호출자는 다른 작업 수행 가능.
                <br><br>
                <strong>2. 동기(Synchronous) vs 비동기(Asynchronous): 직접 체크 </strong><br>
                호출되는 함수의 작업 완료 여부를 함수가 체크하는지를 기준으로 구분<br><br>
                - <strong>동기:</strong> 호출한 함수가 직접 작업 완료를 기다리거나 체크하는 방식<br>
                - <strong>비동기:</strong> 호출한 함수가 작업 완료를 기다리지 않고, 완료되면 콜백 등을 통해 알림 받는 방식<br>
                <br><br>
                <strong>블로킹/논블로킹은 시스템 관점!</strong><br>
                CPU가 그 작업 때문에 묶여 있는지 여부<br>
                I/O, 스레드 관리에서 중요함.<br>
                ex) 파일을 읽는 함수가 CPU를 잡고 기다리게 하면 블로킹<br>
                <br>
                <strong>동기/비동기는 개발자 관점!</strong><br>
                함수 결과를 직접 받아야만 다음 일을 할 수 있는지, 아니면 나중에 콜백이나 이벤트로 받을 수 있는지<br>
                흐름 설계, UI 응답성에 중요<br>
                <br><br>
                💡 + 개념적으로는 이렇게 정리하고, 실무에서 어떻게 사용하고 어떤 영향이 있는지도 알아야함!
                <br><br>
            </p>
            <p><strong>A. 실제 사례</strong><br><br>
                <strong>예시 1: Node.js</strong><br>
                Node.js는 싱글 스레드이기 때문에, I/O 작업을 논블로킹, 비동기로 처리함으로써 CPU가 한 작업에 묶이지 않도록 설계된 구조
                <br><br>
                <strong>1) Node.js는 싱글 스레드 기반</strong><br>
                - Node.js는 기본적으로 싱글 스레드에서 JavaScript 코드를 실행<br>
                - JS 언어 자체가 원래 <strong>브라우저에서 UI처리용으로 설계된 싱글 스레드 언어였기 때문!</strong><br>
                <br>
                <strong>2) 싱글 스레드라서 논블로킹 I/O가 필요하다</strong><br>
                - 하나의 요청이 오래 걸리면 다른 요청을 막아버릴 수 있다는 단점이 있음.<br>
                - 그래서 <strong>I/O 작업(파일, 네트워크 등)은 논블로킹으로 처리해야 전체 성능이 유지됨.</strong><br>
                → I/O는 백그라운드에서 처리하고, 결과만 나중에 전달받는 구조<br>
                <br>
                <strong>3) 논블로킹 I/O를 구현하기 위해 이벤트 루프 구조를 사용한다.</strong><br>
                - 이벤트 루프는 요청 > 등록 > 완료되면 콜백 실행 흐름을 관리하는 역할.<br>
                - 이 구조 덕분에 <strong>비동기 처리가 가능!</strong><br>
                <br><br>
                <strong>I/O 작업</strong>: CPU가 직접 데이터를 처리하지 않고, 외부 장치와 데이터를 주고 받는 작업<br>
                ex) 파일, 네트워크, 데이터베이스<br>
                <br>
                <strong>* 파일 읽기는 왜 I/O 작업일까?</strong><br>
                파일은 하드디스크(SSD)라는 외부 장치에 저장되어 있기 때문에,<br>
                파일을 읽거나 쓰는 작업은 CPU 입장에서 보면 <strong>외부 장치와 데이터를 주고 받는 I/O 작업</strong>으로 분류됨!<br>
                파일 읽기는 CPU가 직접 처리하는 것이 아니라, 운영체제가 디스크에 요청을 보내고 데이터가 준비되면 다시 CPU에 전달해주는 구조.<br>
                - Input(입력): 디스크에서 메모리로 데이터를 가져오는 것 = 파일 읽기<br>
                - Output(출력): 메모리에서 디스크로 데이터를 저장하는 것 = 파일 쓰기<br>
                <br>
                <strong>* 네트워크 I/O</strong><br>
                네트워크 장치를 통해 외부 컴퓨터/서버와 데이터를 주고 받는 통신이기 때문<br>
                - HTTP 요청 및 응답 처리<br>
                - 소켓 통신(TCP, WebSocket 등)<br>
                - API 호출<br>
                <br>
                <strong>* 데이터베이스 I/O</strong><br>
                - DB에 데이터 조회, 삽입, 수정, 삭제<br>
                <br><br><br>
                <strong>예시 2: MSA 기반에서의 비동기 처리</strong><br>
                마이크로서비스 아키텍처에서는 하나의 서비스가 여러 하위 서비스를 호출해야 하는 경우가 많다.<br>
                각 API가 블로킹 방식이라면, 모든 응답을 기다리느라 전체 응답이 지연된다.<br>
                <br>
                → 이를 개선하기 위해 화면에 꼭 먼저 보여줘야 할 정보만 먼저 응답하고, 나머지는 비동기적으로 처리해 순차적으로 불러오는 방식을 사용한다.<br><br>
                <strong>2-1. 초기 페이지의 상단 정보는 빠르게 로드하고, 하단은 스크롤 시 비동기로 API 호출한다.</strong>
                <br><br>
                <strong>2-2. 기본 로직만 먼저 처리하고, 나머지는 비동기 메시지로 전환한다.</strong>
                <br><br>
                사용자가 앱을 열었을 때 아래와 같은 데이터를 서버에서 내려줘야 함.<br>
                - 로그인 여부(필수)<br>
                - 사용자 기본 정보(필수)<br>
                - 알림 목록(중요하지만 늦어도 됨)<br>
                - 추천 상품(성능 부담 큼, 늦어도 무관)<br>
                <br>
                이 모든 데이터를 동기 + 블로킹 방식으로 가져옴<br>
                추천 상품 서비스가 느릴 경우, 전체 응답이 지연되면서 사용자 화면이 5~6초 늦게 열리게 됨.<br>
                <br>
                개선방식<br>
                - 로그인 여부와 사용자 기본 정보는 동기적으로 빠르게 처리해서 즉시 응답에 포함<br>
                - 알림 목록과 추천 상품 요청은 RabbitMQ 같은 메시지 큐에 비동기 메시지로 전송<br>
                <br>
                사용자에게는 1초 내에 핵심 정보만 우선 응답.<br>
                나머지 데이터는 백그라운드에서 처리한 후, 클라이언트는 별도 API나 WebSocket, SSE 등으로 점진적으로 필요한 데이터를 받아와서 UI를 업데이트함.<br>
                <br><br>
            </p>
            <details>
                <summary>참고하면 좋을 글</summary>
                운영체제를 보다 보면 프로세스나 스레드, I/O를 다루면서 동기와 비동기, 블로킹과 논블로킹에 대해서 본 적이 있을 것이다.
                <br><br>
                MSA 환경으로 대형 서비스들이 체질 개선을 하게 되면서 자바 진영의 HTTP client 모듈들도 RestTemplate(멀티 스레드, 블로킹)에서 WebClient(싱글 스레드, 논블로킹) 방식의 기술로 대체되기 시작했다. RestTemplate의 경우 스프링 5.0부터 더이상 유지보수하지 않기로 하여 deprecated가 되었고 WebClient로 사용할 것을 권고하고 있다.
                (= Spring(Java 진영)에서 HTTP 클라이언트 기술이 블로킹 방식에서 논블로킹 방식으로 바뀌고 있다는 의미)
                <br><br>
                또한, 하나의 서비스가 다른 여러 서비스를 호출하는 방식(MSA 기반의 API 호출)으로 바뀌다 보니 네트워크 지연에 민감해지고 호출 결과의 응답 시간에 부담을 느끼기 시작했다.
                가벼운 데이터면 모르지만 MSA나 분산 환경을 적용한 아키텍처라면 시스템이 무겁고 데이터가 많다는 것을 전제로 하기 때문에 속도 측면의 성능 관리가 중요하다.
                <br><br>
                한꺼번에 몇 개의 다른 API를 호출한다고 가정했을 때, 별다른 조치를 하지 않으면 API마다 호출 후 응답이 올 때까지 블로킹되어 있을 것이다.
                각 API가 3초씩 걸린다 치고 10개의 요청이 오면 30초가 지난 뒤에야 로직이 완성되어 화면에 뿌려진다.
                <br><br>
                이러한 이유로 기본적인 로직만 처리한 후 나머지 부분은 비동기로 전환해 큐를 발급하거나 별도의 처리를 해두되, 뒷단에서의 처리와 상관없이 클라이언트에는 응답을 바로 내려주는 형태로 개발 방식도 변화했다.(비동기 메시지)
                그런 뒤, 화면에 뿌려야 할 영역별로 API 호출을 나눠서, 먼저 보여지는 영역은 클라이언트 화면에 로드해온다면 더 늦게 로드되는 페이지도 기다림 없이 순차적으로 전환될 것이다.
                <br><br>
                개념과 차이, 어떤 기술에 적용되는지 숙지해야 제대로 설명할 수 있다. 면접관이 단순히 동기와 비동기, 블로킹과 논블로킹의 개념을 묻는게 아니다.
                <br>
                출처: 연봉 앞자리를 바꾸는 개발자 기술 면접 노트
            </<details>
        </li>
    </ul>

</details>
