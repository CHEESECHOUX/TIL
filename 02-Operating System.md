## 운영체제

## ✔️ Tech-Interview

<details>
    <summary><h3>
        블로킹 vs 논블로킹, 동기 vs 비동기
    </h3></summary>
    <ul>
        <li>
            <p><strong>
                Q. 블로킹과 논블로킹, 동기와 비동기의 차이를 설명하고 각 개념을 적용할 수 있는 구체적인 사례를 설명해보세요.
            </strong></p>
            <p> 💡 블로킹/논블로킹, 동기/비동기의 개념은 서로 조합되어 사용될 수 있다.
                실무에서 성능 최적화, UX 개선에 자주 사용됨.<br>
                <br>
                <strong>A. 개념 정리</strong><br><br>
                <strong>1. 블로킹(Blocking) vs 논블로킹(Non-blocking): 제어권</strong><br>
                호출되는 함수가 결과 나올 때까지 대기하는가? 제어권을 넘겨주고 바로 다른 일을 하러 가는가?<br><br>
                - <strong>블로킹:</strong> 호출된 함수가 작업이 끝날 때 까지 제어권을 반환하지 않고 기다리는 방식<br>
                - <strong>논블로킹:</strong> 작업을 요청하면 바로 제어권을 돌려주고, 나중에 콜백이나 이벤트로 결과를 받는 방식. 호출자는 다른 작업 수행 가능.
                <br><br>
                <strong>2. 동기(Synchronous) vs 비동기(Asynchronous): 직접 체크 </strong><br>
                호출되는 함수의 작업 완료 여부를 함수가 체크하는지를 기준으로 구분<br><br>
                - <strong>동기:</strong> 호출한 함수가 직접 작업 완료를 기다리거나 체크하는 방식<br>
                - <strong>비동기:</strong> 호출한 함수가 작업 완료를 기다리지 않고, 완료되면 콜백 등을 통해 알림 받는 방식<br>
                <br><br>
                <strong>블로킹/논블로킹은 시스템 관점!</strong><br>
                CPU가 그 작업 때문에 묶여 있는지 여부<br>
                I/O, 스레드 관리에서 중요함.<br>
                ex) 파일을 읽는 함수가 CPU를 잡고 기다리게 하면 블로킹<br>
                <br>
                <strong>동기/비동기는 개발자 관점!</strong><br>
                함수 결과를 직접 받아야만 다음 일을 할 수 있는지, 아니면 나중에 콜백이나 이벤트로 받을 수 있는지<br>
                흐름 설계, UI 응답성에 중요<br>
                <br><br>
                💡 + 개념적으로는 이렇게 정리할 수 있지만, 실무에서 어떻게 사용하고 어떤 영향이 있는지는 별도로 공부해야함!
                <br><br>
            </p>
            <p><strong>A. 실제 사례</strong><br><br>
                <strong>예시 1: Node.js의 논블로킹 처리</strong><br>
                Node.js는 싱글 스레드 기반의 이벤트 루프 모델을 사용하며, 논블로킹과 비동기 처리가 기본 동작 방식으로 설계된 런타임
                <br><br>
                <strong>예시 2: MSA 기반에서의 비동기 처리</strong><br>
                마이크로서비스 아키텍처에서는 하나의 서비스가 여러 하위 서비스를 호출해야 하는 경우가 많다.<br>
                각 API가 블로킹 방식이라면, 모든 응답을 기다리느라 전체 응답이 지연된다.<br>
                <br>
                => 이를 개선하기 위해 화면에 꼭 먼저 보여줘야 할 정보만 먼저 응답하고, 나머지는 비동기적으로 처리해 순차적으로 불러오는 방식을 사용한다.<br><br>
                <strong>2-1. 초기 페이지의 상단 정보는 빠르게 로드하고, 하단은 스크롤 시 비동기로 API 호출한다.</strong>
                <br><br>
                <strong>2-2. 기본 로직만 먼저 처리하고, 나머지는 비동기 메시지로 전환한다.</strong>
                <br><br>
                사용자가 앱을 열었을 때 아래와 같은 데이터를 서버에서 내려줘야 함.<br>
                - 로그인 여부(필수)<br>
                - 사용자 기본 정보(필수)<br>
                - 알림 목록(중요하지만 늦어도 됨)<br>
                - 추천 상품(성능 부담 큼, 늦어도 무관)<br>
                <br>
                이 모든 데이터를 동기 + 블로킹 방식으로 가져옴<br>
                추천 상품 서비스가 느릴 경우, 전체 응답이 지연되면서 사용자 화면이 5~6초 늦게 열리게 됨.<br>
                <br>
                개선방식<br>
                - 로그인 여부와 사용자 기본 정보는 동기적으로 빠르게 처리해서 즉시 응답에 포함<br>
                - 알림 목록과 추천 상품 요청은 RabbitMQ 같은 메시지 큐에 비동기 메시지로 전송<br>
                <br>
                사용자에게는 1초 내에 핵심 정보만 우선 응답.<br>
                나머지 데이터는 백그라운드에서 처리한 후, 클라이언트는 별도 API나 WebSocket, SSE 등으로 점진적으로 필요한 데이터를 받아와서 UI를 업데이트함.<br>
                <br><br>
            </p>
            <details>
                <summary>참고하면 좋을 글</summary>
                운영체제를 보다 보면 프로세스나 스레드, I/O를 다루면서 동기와 비동기, 블로킹과 논블로킹에 대해서 본 적이 있을 것이다.
                <br><br>
                MSA 환경으로 대형 서비스들이 체질 개선을 하게 되면서 자바 진영의 HTTP client 모듈들도 RestTemplate(멀티 스레드, 블로킹)에서 WebClient(싱글 스레드, 논블로킹) 방식의 기술로 대체되기 시작했다. RestTemplate의 경우 스프링 5.0부터 더이상 유지보수하지 않기로 하여 deprecated가 되었고 WebClient로 사용할 것을 권고하고 있다.
                (= Spring(Java 진영)에서 HTTP 클라이언트 기술이 블로킹 방식에서 논블로킹 방식으로 바뀌고 있다는 의미)
                <br><br>
                또한, 하나의 서비스가 다른 여러 서비스를 호출하는 방식(MSA 기반의 API 호출)으로 바뀌다 보니 네트워크 지연에 민감해지고 호출 결과의 응답 시간에 부담을 느끼기 시작했다.
                가벼운 데이터면 모르지만 MSA나 분산 환경을 적용한 아키텍처라면 시스템이 무겁고 데이터가 많다는 것을 전제로 하기 때문에 속도 측면의 성능 관리가 중요하다.
                <br><br>
                한꺼번에 몇 개의 다른 API를 호출한다고 가정했을 때, 별다른 조치를 하지 않으면 API마다 호출 후 응답이 올 때까지 블로킹되어 있을 것이다.
                각 API가 3초씩 걸린다 치고 10개의 요청이 오면 30초가 지난 뒤에야 로직이 완성되어 화면에 뿌려진다.
                <br><br>
                이러한 이유로 기본적인 로직만 처리한 후 나머지 부분은 비동기로 전환해 큐를 발급하거나 별도의 처리를 해두되, 뒷단에서의 처리와 상관없이 클라이언트에는 응답을 바로 내려주는 형태로 개발 방식도 변화했다.(비동기 메시지)
                그런 뒤, 화면에 뿌려야 할 영역별로 API 호출을 나눠서, 먼저 보여지는 영역은 클라이언트 화면에 로드해온다면 더 늦게 로드되는 페이지도 기다림 없이 순차적으로 전환될 것이다.
                <br><br>
                개념과 차이, 어떤 기술에 적용되는지 숙지해야 제대로 설명할 수 있다. 면접관이 단순히 동기와 비동기, 블로킹과 논블로킹의 개념을 묻는게 아니다.
                <br>
                출처: 연봉 앞자리를 바꾸는 개발자 기술 면접 노트
            </<details>
        </li>
    </ul>

</details>
