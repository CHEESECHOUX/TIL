# 배포 시스템

<details>
    <summary><h3>CI/CD</h3></summary>
    <h4>✔️ 배포 시스템이 왜 필요할까?</h4>
    <ul>
    <li>개발한 코드를 서버에 반영해 실제 서비스에 적용해야 되니까</li>
    </ul>
    <br>
    <h2>배포 목표(= 배포 시스템의 기능적 요구사항)</h2>
    <ul>
    <li><strong>서비스 중단 없이</strong> 배포하고, 문제가 생기면 <strong>빠르게 롤백</strong>하거나 트래픽을 전환할 수 있어야 함</li>
    <li><strong>배포 중 에러나 장애를 자동 감지</strong>하고 확인할 수 있어야 함
        <ul>
        <li>예: Health check 기능을 통해 각 인스턴스의 Endpoint 상태나 시스템 리소스(CPU, Memory 등)를 실시간으로 확인</li>
        </ul>
    </li>
    <li><strong>로그 및 시스템 상태를 모니터링</strong>할 수 있어야 함
        <ul>
        <li>예: 메트릭 수집 및 로그 분석 도구(Grafana, ELK 등)와 연동해 지표 및 에러 상황을 추적</li>
        </ul>
    </li>
    <li><strong>협업이 원활하고 실수를 줄일 수 있도록 자동화</strong>되어야 함
        <ul>
        <li>예: 배포 준비, 설정 변경 자동화</li>
        <li>배포 Lock/Unlock 기능으로 실수 방지</li>
        <li>Slack·카카오톡 등으로 실시간 알림 연동</li>
        </ul>
    </li>
    <li><strong>배포 이력 기록</strong>이 남아 있어야 함
        <ul>
        <li>누가, 언제, 어떤 코드를 배포했는지 확인</li>
        <li>문제가 생겼을 때 <strong>원인을 빠르게 추적</strong> 가능</li>
        <li>예: 배포 시간, 버전 정보, 담당자 기록 자동 저장</li>
        </ul>
    </li>
    <li><strong>버전 관리가 체계적이어야 함</strong>
        <ul>
        <li>예: [업무티켓명-번호]-모듈명-[yyyyMMddHHmmss] 형식의 자동 빌드 버전 생성</li>
        </ul>
    </li>
    <li><strong>배포 상태를 실시간으로 파악할 수 있어야 함</strong>
        <ul>
        <li>예: Dev / Stage / Production 단계별 상태를 시각적으로 보여주는 Progress Viewer</li>
        </ul>
    </li>
    </ul>
    <br>
    <h2>CI/CD란?</h2>
    <p><h3>CI 단계</h3>코드 테스트 + 빌드 (예: 도커 이미지 생성)<br>
    <h3>CD 단계</h3>배포 전략 실행 (롤링, 블루/그린, 카나리 등)</p><br>
    <h3>🔹 CI (Continuous Integration 지속적 통합)</h3>
    <ul>
    <li>개발자의 코드를 <strong>공통 브랜치에 자주 병합</strong></li>
    <li><strong>자동 빌드 / 테스트 / 코드 품질 검증</strong>을 수행해, 통합 시 <strong>오류를 조기에 발견하고 빠르게 배포</strong>할 수 있도록 하는 프로세스</li>
    </ul>
    <br>
    <h3>🔹 CD (Continuous Delivery/Deployment 지속적 배포)</h3>
    <ul>
    <li>테스트 통과된 <strong>빌드 결과물을 자동으로 운영환경까지 배포</strong>하는 것</li>
    <li>Delivery: 스테이징까지 자동화 (운영 서버 배포는 수동)<br>
    Deployment: 운영 서버 배포까지 자동화<br>
    </li>
    <br>
    ✔️ 스테이징: 운영 서버(프로덕션)과 거의 동일하게 만든 테스트용 환경<br>
    </ul>
    <br>
    <h2>배포 전략</h2>
    * <strong>롤링, 블루/그린, 카나리 배포</strong>는 모두 <strong>무중단 배포</strong>를 전제로 하기 때문에, <strong>최소 2개 이상의 인스턴스</strong>가 필요함<br>
    * <strong>롤링 배포</strong>는 <strong>스타트업이나 중소기업</strong>에서, <strong>블루/그린, 카나리 배포</strong>는 <strong>대형 시스템이나 클라우드 환경</strong>에서 더 선호된다.<br>
    <br><br>
    <h3>1. 롤링 배포</h3>
    <ul>
    <li><strong>여러 서버(인스턴스) 중에서 하나씩 순차적으로 새 버전으로 교체</strong></li>
    <li>각 인스턴스는 트래픽을 잠시 차단 → 업데이트 진행 → 완료되면 서비스에 연결</li>
    <li>이 과정을 반복하면서, <strong>모든 서버에 새 버전을 점진적으로 배포</strong></li>
    </ul><br>
    <strong>장점</strong>
    <ul>
    <li><strong>추가 서버 비용 없음</strong><br>(= 기존에 운영 중인 인스턴스를 하나씩 업데이트하면서 순차적으로 배포하므로, 배포를 위해 인스턴스를 추가로 띄울 필요가 없음)</li>
    <li><strong>관리 간편</strong></li>
    </ul>
    <strong>단점</strong>
    <ul>
    <li>배포 시점에 인스턴스마다 서로 다른 버전일 수 있어, <strong>사용자에게 어떤 버전이 보일지 알 수 없음.</strong></li>
    <li><strong>서버 수가 많을 경우 시간 오래 걸림</strong></li>
    <br>
    <li>💡 롤링 배포는 <strong>배포 컴포넌트들이 시간이 지날수록 무거워지고 서비스 트래픽에 영향을 많이 받게 된다.</strong> 
        일반적인 방식이지만 좋은 방식의 배포는 아니다.<br>
        → 이 단점을 상쇄하기 위해 <strong>배포 소스의 규모를 작게 나누는 MSA로 진행</strong>하거나, <strong>트래픽이 몰리지 않는 시간대에 배포</strong>하는 방법으로 해결<br>
    </li>
    </ul>
    <br>
    <h3>2. 블루/그린 배포</h3>
    <ul>
    <li><strong>구버전(Blue)과 신버전(Green)</strong> 인스턴스를 <strong>병렬</strong> 운영</li>
    <li><strong>LB를 통해</strong> 트래픽을 신버전(Green)으로 전환</li>
    </ul><br>
    <strong>장점</strong>
    <ul>
    <li>문제가 있을 경우 <strong>롤백이 빠르다.</strong> (LB만 원위치)</li>
    <li>새 버전을 먼저 따로 배포하고 검증하므로, <strong>전환 전까지 운영 환경은 100% 안전하게 유지 가능</strong></li>
    </ul>
    <strong>단점</strong>
    <ul>
    <li><strong>시스템 자원이 2배 필요</strong><br> (EC2 인스턴스는 반드시 2배가 되어야 하고, RDS는 공유 여부에 따라 달라짐)</li>
    <li>새 배포 버전이 나갈 때 반드시 <strong>QA를 꼼꼼히 점검</strong>해 버그나 장애 유발 가능성을 낮춰야 한다.<br>
        → 그린에 문제가 있으면 모든 사용자에게 장애가 발생하기 때문
    </li>
    </ul>
    <br>
    <h3>3. 카나리 배포</h3>
    <ul>
    <li><strong>일부 사용자에게만 신규 버전을 배포</strong>한 뒤 <strong>점진적 확대</strong></li>
    <li>오래 전 광부들이 가스에 민감한 카나리아 새를 탄광에 풀어 미리 가스 누출 위험을 감지한데서 유래</li>
    </ul><br>
    <strong>장점</strong>
    <ul>
    <li>문제 발생 시 영향 최소화 (점진적으로 배포하기 때문에 블루/그린보다 안전)</li>
    <li><strong>A/B 테스트 가능</strong></li>
    </ul>
    <strong>단점</strong>
    <ul>
    <li><strong>트래픽 분산 전략이 복잡함</strong><br>기존 버전과 새 버전을 동시에 운영하면서, 일부 사용자만 정해진 비율로 새 버전으로 보내야 함.</li>
    <li><strong>사용자 구분 로직이 필요함</strong><br>누가 새 버전을 쓸지 정해야 하고, 코드나 인프라에서 사용자 조건에 따른 분기처리나 경우에 따라 DB나 로직 설계도 함께 고려해야 함.</li>
    </ul>
    <br>
    <h2>배포 시스템 시나리오 예시</h2>
    <ol>
    <li><strong>새로운 버전 변경 커밋 → 리뷰 및 머지 → 배포 내용 공유</strong></li>
    <li><strong>새로운 버전 빌드 수행 및 다른 사람이 실수로 배포 버튼을 누르지 못하게 배포 잠금(Lock)</strong></li>
    <li><strong>테스트 환경(Dev → Stage → Prod) 단계별로 순차 배포 진행</strong>
        <ul>
        <li>테스트 결과에 문제가 없으면, 운영(Prod) 환경에서는 <strong>카나리 방식</strong>으로 일부 인스턴스에만 배포</li>
        <li>지정된 비율로 트래픽을 분산하며 점진적 배포</li>
        <li><strong>오류 발생 시, 이전 버전 형상으로 즉시 롤백</strong> 가능해야 함</li>
        </ul>
    </li>
    <li><strong>테스트 단계에서는 수동으로 핫픽스(Hotfix) 버전을 배포할 수 있어야 하므로,<br>
        메뉴얼 배포 기능(수동으로 배포할 수 있는 시스템 UI 또는 기능)도 제공되어야 함</strong></li>
    <li><strong>문제 없으면 전체 배포 진행</strong>
        <ul>
        <li>배포 이력 기록 (배포 시간, 배포한 사람)</li>
        <li>기존 연결 정리 및 새 인스턴스 전환</li>
        <li>롤백을 위해 재빌드하는 방식은 지양</li>
        </ul>
    </li>
    <li><strong>배포 완료 알림 전송</strong> (= 자동으로 배포 성공/실패 공유)</li>
    <li><strong>자동으로 배포 히스토리 기록, 릴리즈 태그 생성, 이슈가 있을 경우 로그와 함께 파악할 수 있도록 대시보드 지원</strong></li>
    <li><strong>전체 모니터링 후 배포 프로세스 종료</strong></li>
    </ol>
    <br>
    * 핫픽스(Hotfix): 프로덕션 환경에서 긴급하게 발견된 문제를 빠르게 수정한 버전<br>
</details>

<br>

## ✔️ Tech-Interview

<details>
    <summary><strong>CI/CD를 적용하는 이유가 무엇인가요?</strong></summary>
    <br>
    <strong>개발부터 배포까지의 과정을 자동화</strong>해 <strong>코드 변경 사항</strong>을 <strong>빠르고 안정적으로 서비스에 반영</strong>하기 위해 적용합니다.<br>
    CI는 코드 변경을 <strong>자주 통합하고 자동 빌드, 테스트</strong>를 통해 <strong>버그를 조기에 발견</strong>하고,<br>
    CD는 <strong>테스트를 통과한 코드</strong>를 <strong>안정적이고 반복 가능한 방식</strong>으로 <strong>배포</strong>해 릴리즈 속도를 높이고 운영 리스크를 줄입니다.<br>
    <br>
    결과적으로 <strong>개발 생산성 향상, 서비스 품질 안정화, 릴리즈 주기 단축</strong>이라는 이점이 있습니다.<br>
    (릴리즈 주기 단축: 배포 준비와 검증 과정이 자동화되기 때문)<br>
</details>
<br>
<details>
    <summary><strong>본인이 전사에서 사용할 공통 CI/CD 솔루션을 만든다고 가정했을 때 어떤 기능을 넣어야 할지 각 프로세스 단위로 설명해주실 수 있을까요?</strong></summary>
    <h3>CI/CD 각 프로세스 단위 기능</h3>
    <h4>🔸 코드 병합 및 빌드</h4>
    <ul>
    <li>Git 기반 버전 관리</li>
    <li>커밋/머지 시 자동 빌드 트리거</li>
    <li>도커 이미지 생성</li>
    <li>빌드 버전 명명 규칙 자동화 (예: [티켓명]-[모듈명]-[yyyyMMddHHmmss])</li>
    </ul>
    <h4>🔸 테스트 자동화</h4>
    <ul>
    <li>유닛 테스트 / 통합 테스트 자동 실행</li>
    <li>테스트 실패 시 병합 차단 또는 알림</li>
    <li>결과 리포트 생성</li>
    </ul>
    <h4>🔸 배포 자동화</h4>
    <ul>
    <li>롤링 / 블루그린 / 카나리 등 다양한 배포 전략 지원</li>
    <li>환경별 배포 단계 (Dev → Stage → Prod)</li>
    <li>배포 Progress Viewer</li>
    <li>배포 Lock / Unlock 기능</li>
    </ul>
    <h4>🔸 롤백 지원</h4>
    <ul>
    <li>재빌드 없이 이전 버전으로 즉시 전환</li>
    <li>버전별 트래픽 라우팅 제어</li>
    <li>장애 발생 시 자동 Rollback 옵션</li>
    </ul>
    <h4>🔸 모니터링</h4>
    <ul>
    <li>Endpoint 헬스 체크</li>
    <li>시스템 리소스(CPU, Memory, Disk) 모니터링</li>
    <li>전체 로그 수집 및 지표 통합</li>
    <li>대시보드에서 상태 시각화</li>
    </ul>
    <h4>🔸 히스토리 기록</h4>
    <ul>
    <li>배포자 / 시간 / 버전 정보 자동 저장</li>
    <li>릴리즈 버전 태그 자동 생성</li>
    <li>변경 이력 추적 가능</li>
    </ul>
    <h4>🔸 알림</h4>
    <ul>
    <li>배포 시작/종료/결과 Slack·카카오톡·이메일 자동 발송</li>
    <li>알림을 통한 배포 상황 실시간 공유</li>
    </ul>
    <h4>🔸 중앙 관제 연동</h4>
    <ul>
    <li>배포 결과를 API 또는 로그 형태로 중앙 시스템에 기록</li>
    <li>장애 발생 시 중앙 관제 시스템에서 추적 가능</li>
    </ul>
    <h4>🔸 통계 및 시각화</h4>
    <ul>
    <li>전체 배포 현황 대시보드</li>
    <li>로그 뷰어</li>
    <li>메트릭 기반 시각화 그래프 제공</li>
    </ul>
</details>
<br>
<details>
    <summary><strong>Q2. 애플리케이션의 다운타임을 최소화하기 위한 기본적인 배포 방식을 설명해주세요.</strong></summary>
    <br>
    * 다운타임: 사용자나 외부 시스템이 서비스에 접근할 수 없는 시간<br>
    <br>
    다운타임을 최소화 하려면 <strong>무중단 배포 전략이 필요함!</strong><br>
    A. 롤링, 블루/그린, 카나리 배포에 대해 설명
</details>
<br>
<details>
    <summary><strong>Q3. 서버 점검 페이지 없이 365일 24시간 내내 애플리케이션이 운영되기 위한 배포 전략이나 필요한 시스템 구성은 어떤 것이 있을까요?</strong></summary>
    <br>
    * 무중단 운영을 위한 배포 전략 및 시스템 구성을 물어보는 것!<br>
    <br>
    <ul>
        <li><strong>배포 전략</strong><br> 블루/그린 또는 카나리 방식 적용</li>
        <li><strong>트래픽 분리</strong><br> LB/Ingress 기반 헬스체크 후 안전한 전환</li>
        <li><strong>자동화 도구</strong><br> GitHub Actions, ArgoCD, Spinnaker 등</li>
        <li><strong>모니터링</strong><br> Prometheus, Grafana, ELK, CloudWatch 등 활용</li>
        <li><strong>알림 및 기록</strong><br> 배포 이력 자동 기록 + Slack 알림</li>
        <li><strong>고가용성 인프라</strong><br> Auto Scaling, Multi-AZ 구성, DB 이중화</li>
        <li><strong>중앙 통제</strong><br> 로그 및 메트릭 통합 수집, 관제 대시보드</li>
    </ul>
</details>
<br>
<details>
    <summary><strong>+ 별도로 배포 시스템이 분리되어야 하는 경우</strong></summary>
    <br>
    <ul>
        <li><strong>보안이 중요한 경우:</strong> 금융 시스템, 민감한 데이터 분리 필요</li>
        <li><strong>특수 인프라:</strong> IoT, OTA 등 고유 배포 환경</li>
        <li><strong>외부 협력사:</strong> 파트너와 공동 개발 시 별도 구성 필요</li>
        <li><strong>레거시 시스템:</strong> 완전한 통합 전까지 분리 유지</li>
    </ul>
    단, 이런 경우에도 전사 인프라에 영향을 주지 않도록 <strong>격리 및 관제 연동</strong>이 필요함!
</details>
