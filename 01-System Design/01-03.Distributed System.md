# 분산 시스템 설계

<details>
    <summary><h3>수평 확장, 수직 확장</h3></summary>
    <h3>1. 수평 확장 (Scale Out)</h3>
    <strong>서버 대수를 늘려 트래픽을 분산 처리</strong><br><br>
    <ul>
    <li><strong>적용 상황:</strong> 이벤트 등으로 <u>트래픽이 일시적으로 급증</u>할 때</li>
    <li><strong>운영 방식:</strong> 한계치 트래픽 규모 예측 → 서버 추가 → 로드 밸런서로 분산 처리</li>
    <li><strong>장점:</strong> <u>가용성 향상</u>, 트래픽에 탄력적으로 대응 가능</li>
    <li><strong>단점:</strong>
        <ul>
        <li>세션 관리, 데이터 정합성 유지가 복잡</li>
        <li>서버 수 증가로 인한 <u>운영/관리 비용(인적 자원, 시스템 자원) 증가</u></li>
        </ul>
        <br>
        + 추가) 분산 환경에서 세션 관리, 데이터 정합성 관리 어떻게 하는지 
    </li>
    </ul>
    <br>
    <h3>2. 수직 확장 (Scale Up)</h3>
    <strong>기존 서버의 사양을 업그레이드 (CPU, 메모리 확장 or 고성능 서버 교체)</strong><br><br>
    <ul>
    <li><strong>적용 상황:</strong>
        <ul>
        <li><u>단일 트랜잭션 비즈니스 로직</u>이 매우 복잡하거나</li>
        <li><u>대량 데이터 처리가 필요하고, 통계와 집계, 배치</u>등의 처리 주 업무인 서버</li>
        </ul>
    </li>
    <li><strong>판단 기준:</strong> CPU, 메모리 사용률이 <u>60% 를 초과</u>해 지속적으로 증가할 때</li>
    <li><strong>장점:</strong> 분산 시스템보다 <u>관리 용이</u></li>
    <li><strong>단점:</strong>
        <ul>
        <li>서버 교체 시 <u>다운타임 발생</u> 가능</li>
        <li><u>확장 한계</u> 존재 (하드웨어 물리적 한계)</li>
        </ul>
    </li>
    </ul>
</details>

<br>

## ✔️ Tech-Interview

<details>
    <summary><h3>비동기 메시지 처리(Message Queue)</h3></summary>
    <blockquote>
        <strong>Q.</strong> 온라인 사이트에서 특정 상품의 구매 이력이 있는 회원에게 간단한 설문을 요청한 후, 제출하면 자동으로 1만원 상당의 스타벅스 기프티콘을 주는 이벤트를 한다고 가정한다. 
        하루 동안 진행되고 판매사와 계약 관계 등을 고려해 정시에 오픈 후 목표한 기프티콘이 소진되면 이벤트를 종료한다고 할 때 어떤 방식의 아키텍처를 고려해야 할까?
    </blockquote>
    <br>
    <p><strong>→ 당일 이벤트이기 때문에 몇 분 이내에 접속이 폭주할 것!</strong></p>
    <br>
    <h3>1. 트래픽 처리</h3>
    <strong>문제점</strong>
    <ul>
        <li>구매/설문 페이지에 급격한 접속 증가</li>
        <li>기프티콘 전송 로직의 병목 가능성</li>
        <li>회원 정보 조회 부하로 전체 로그인/회원가입까지 영향</li>
    </ul>
    <br>
    <strong>해결 방안</strong>
    <ol>
        <li><strong>비동기 처리 구조 도입</strong><br>
            - HTTP 200 응답만 빠르게 반환(응모 성공 메시지)<br>
            - 설문/응모 데이터는 MQ에 저장하고 별도 처리</li><br>
        <li><strong>이벤트 응답 전용 테이블 분리</strong><br>
            - 응모 데이터(회원 ID, 설문 결과, 응모 시간 등 이벤트 참여 데이터)만 저장해 DB I/O 최소화<br>
            (= 다른 테이블에는 접근하거나 영향을 주지 않도록)
        </li><br>
        <li><strong>트랜잭션 분리</strong><br>
            - MQ를 통해 회원 인증 / 재고 차감 / 기프티콘 전송을 분리 처리</li><br>
    </ol>
    <h3>2. 재고 관리</h3>
    <strong>문제점</strong>
    <ul>
        <li>RDB에서 UPDATE로 수량 차감 시 동시성 병목</li>
        <li>재고 수량 처리 중 데이터 정합성 오류 위험</li>
    </ul>
    <br>
    <strong>해결 방안</strong>
    <h4>Redis 기반 재고 관리</h4>
    <ul>
        <li><strong>레디스는 싱글 스레드 기반</strong>으로 여러 클라이언트 요청을 동시에 처리하지 않고, <strong>하나의 스레드로 순차적으로 처리</strong>한다.</li>
        <li>decr 같은 원자 연산 사용<br>
            (= 동시성 문제 없이 수량을 안전하게 줄이기 위해 사용하는 명령)</li>
        <li>Pub/Sub or 메시지 큐로 이벤트 브로드캐스팅 가능</li>
        <li>TTL 설정으로 이벤트 자동 종료 가능</li>
    </ul>
    <br>
    <ul>
        <li><strong>Redis는 인메모리 기반</strong>으로 <strong>데이터 유실 가능성</strong>이 있다.<br>이를 보완하려면 <strong>클러스터 구성, 백업 정책(AOF/RDB 설정), 디스크 저장 MQ 사용</strong>(RabbitMQ, Kafka는 자체적으로 디스크에 저장)</li>
        <br>
        <li><strong>총 재고 수/지급 수량은 RDBMS에 별도 기록</strong></li>
        <li>안전 재고 확보(ex: 총 100개 중 10개는 오차방지용)</li>
    </ul>
    <br>
    * 이벤트 브로드캐스팅: 시스템에서 어떤 이벤트가 발생했을 때, 여러 컴포넌트(또는 서비스)에게 동시에 그 이벤트를 알려주는 방식.<br>
    설문 제출 후 재고 수량 감소, 응모 DB 기록, 기프티콘 발송 작업이 동시에 필요할 때 <strong>"설문 제출 완료"라는 이벤트를 브로드캐스팅</strong>하면 각각의 처리 담당 서비스가 해당 이벤트를 구독하고 자기 역할을 수행할 수 있음.<br>
    <br><br>
    <h3>3. 메시지 큐(MQ) 도입 이유</h3>
    <p>MQ(Message Queue): 시스템끼리 데이터를 주고받을 때, 바로 처리하지 않고 중간에서 메시지를 안전하게 저장하고 전달해주는 중간 관리자</p>
    <br>
    <strong>구성 요소</strong><br>
    - Producer: 메시지를 보내는 쪽 (ex: 주문 생성 서비스)<br>
    - Queue(MQ): 메시지를 줄 세워 보관하는 공간<br>
    - Consumer: 메시지를 받아서 처리하는 쪽(ex: 결제 처리 서비스)<br>
    <br>
    <strong>왜 필요한가?</strong><br>
    1. 비동기 처리<br>
    Producer가 메시지를 보내고 기다리지 않고 다른 작업을 할 수 있음<br>
    <br>
    2. 시스템 간 결합도 낮춤<br>
    Producer와 Consumer가 직접 연결되지 않아도 됨<br>
    <br>
    3. 트래픽 폭주에 견딜 수 있음<br>
    Queue에 일단 쌓아두고, Consumer가 하나씩 처리<br>
    <br>
    * MQ가 없으면?<br>
    - 모든 처리를 API 서버가 동기적으로 처리 → 응답 지연 / 타임아웃 / 서버 다운<br>
    - 기프티콘 중복 지급 가능성이 높아짐<br>
    - 트래픽에 따라 DB나 외부 API 폭주로 실패할 가능성이 높아짐<br>
    <br>
    <br>
    <p><strong>전체 구조는 비동기 시스템이고, 그 안에서 분산 전송으로 성능을 높임.</strong></p>
    <br>
    <h3>MQ 처리 흐름 예시</h3>
    <ol>
        <li>Producer가 MQ에 메시지를 보냄 → 즉시 반환됨(비동기)</li>
        <li>MQ는 해당 메시지를 큐에 쌓음</li>
        <li>Consumer A, B, C 중 하나가 메시지를 꺼내 처리 → 동시에 여러 Consumer가 처리 (분산)</li>
    </ol>
    <br>
    <h3>설문 이벤트 처리 흐름 예시</h3>
    <ol>
        <li>클라이언트가 설문 제출</li>
        <li>응답 200 반환 + 메시지 큐에 응모 데이터 적재</li>
        <li>Consumer가 큐의 메시지를 꺼내 다음 작업 처리
        <ul>
            <li>Reids 재고 차감</li>
            <li>전화번호 조회(리플리케이션 DB 활용)</li>
            <li>기프티콘 발송(SMS/알림톡)</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>메시지 큐를 이용한 비동기 처리의 특징</h3>
    <ul>
        <li>비동기성: 클라이언트 응답과 백엔드 처리를 분리<br>(= 비동기 메시지를 사용해 다른 응용프로그램 사이에 데이터를 송수신)</li>
        <li>확장성: Consumer 인스턴스 수평 확장 가능<br>(= Consumer 인스턴스 여러 개 띄우기), 시스템을 기능 단위로 분리하고 독립적으로 확장할 수 있어, 모듈 구성과 유지보수가 용이함.</li>
        <li>신뢰성: 실패 시 재처리, 디스크 기반 저장</li>
        <li>관심사의 분리: 각 역할을 독립 모듈로 관리 가능</li>
        <li>트래픽 완화: 처리 속도와 관계없이 요청을 큐에 누적</li>
    </ul>
    <br>
    <br>
    <h2>🚨 비동기 메시지 처리 문제점</h2>
    <h3>1. 메시지 유실 위험</h3>
    <ul>
        <li>메시지가 큐에 들어가기 전에 서버가 죽으면 데이터 손실</li>
        <li>MQ 자체에 장애가 났을때, 영속성 설정이 없으면 메시지 사라질 수 있음</li>
    </ul>
    <br>
    <p><strong>해결 방법</strong></p>
    <ol>
        <li>Persistent 설정
        <ul>
            <li>메시지를 디스크에 저장(persistent) 하겠다고 설정</li>
        </ul>
        </li>
        <li>Acknowledgement(Ack)
        <ul>
            <li>Consumer가 메시지를 정상적으로 처리했다는 응답을 MQ에 보내야 메시지가 삭제됨</li>
            <li>Ack 응답이 없으면 MQ는 처리 안 되었다고 생각하고 다시 전송</li>
        </ul>
        </li>
        <li>디스크 저장 기반 MQ 사용
        <ul>
            <li>Redis 같은 인메모리 큐는 메시지를 메모리에만 저장하므로 유실 위험이 큼.</li>
            <li>Kafka, RabbitMQ는 메시지를 디스크에 저장하는 기능이 기본으로 있음</li>
            <li>=&gt; 장애가 나더라도 하드 디스크에 남아 있는 메시지를 다시 꺼내서 처리 가능</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>2. 중복 처리(Duplication)</h3>
    <ul>
        <li>메시지를 한 번 처리했는데, Consumer가 ack 응답을 못 보냈을 경우 → MQ는 다시 전송</li>
        <li>그 결과 같은 작업이 두 번 실행될 수 있음</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    Idempotent 처리(중복을 허용하지 않는 로직) 설계<br>
    <ul></ul>
        <li>메시지마다 message_id 또는 uuid 부여</li>
        <li>DB나 Redis에 message_id 처리 여부 기록</li>
        <li>같은 ID가 이미 처리된 경우 무시</li>
    </ul>
    <br>
    <h3>3. 처리 순서 보장 어려움</h3>
    <ul>
        <li>MQ는 메시지를 빠르게 처리하기 위해 여러 Consumer에게 메시지를 분산 전송</li>
        <li>이때 네트워크 지연, 처리 속도 차이로 인해 메시지가 도착하거나 처리되는 순서가 달라질 수 있음</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    <ol>
        <li>Kafka 파티션 단위 처리
        <ul>
            <li>메시지를 보낼 때 특정 기준으로(ex: user_id, order_id) 같은 파티션으로 보내도록 설정</li>
            <li>동일한 사용자, 주문 ID 별로 순서가 보장된 채 처리됨</li>
            <li>Kafka는 메시지를 토픽(topic) 안의 여러 파티션에 나눠 저장함.</li>
            <li>같은 파티션 안에서는 메시지 순서가 보장됨(FIFO)</li>
            <li>메시지 순서를 보장하고 싶은 기준(ex: 사용자, 주문 등) 단위로 컨트롤 가능</li>
        </ul>
        </li>
        <li>큐를 분리해서 순서 보장
        <ul>
            <li>순서가 중요한 작업과 그렇지 않은 작업을 나눠서 처리</li>
            <li>=&gt; 순서가 중요한 메시지만 따로 큐를 만들어서 순차 처리</li>
            <li>순서 보장 + 중요하지 않은 작업은 병렬로 빠르게 처리 가능</li>
            <li>또는 고객/주문 단위로 개별 큐를 운용</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>4. 오류 추적 및 디버깅 어려움</h3>
    <ul>
        <li>처리 흐름이 비동기 + 분산되어 있어 문제 발생 시 흐름 추적 어려움</li>
        <li>Producer(메시지를 만드는 쪽 ex: 사용자의 설문 응답을 MQ에 넣는 서버), MQ(메시지를 받아 저장하고 전달하는 중간 시스템), Consumer(메시지를 받아서 실제 처리 담당 ex: 재고 차감, 기프티콘 발송 등)가 각각 로그를 남기므로 디버깅 어려움</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    <ol>
        <li>추적 ID(Correlation ID)
        <ul>
            <li>하나의 요청 흐름을 추적할 수 있도록 공통된 ID를 부여</li>
        </ul>
        </li>
        <li>분산 트레이싱 도구(Jaeger, Zipkin 등)
        <ul>
            <li>요청 흐름이 여러 시스템을 거칠 때, 그 경로를 시각적으로 추적할 수 있는 트레이싱 시스템</li>
        </ul>
        </li>
    </ol>
    <br>
    <h3>5. 복잡도 증가</h3>
    <ul>
        <li>큐 설정, 메시지 포맷, 에러 처리 로직 등 시스템이 복잡해짐</li>
        <li>운영자가 큐를 실수로 삭제하거나, 메세지의 구조를 Producer와 Consumer가 제대로 맞추지 않으면 문제가 생기고, 장애가 더 커질 수 있음</li>
    </ul>
    <p><strong>해결 방법</strong></p>
    <ul>
        <li>1. 표준화된 메시지 스키마 정의 및 검증(ex: JSON Schema, Avro 등)</li>
        <li>2. 큐 운영 모니터링 시스템 구축(ex: RabbitMQ UI, Kafka Manager, Grafana 등)</li>
    </ul>
    <br>
    <h3>6. 트랜잭션 일관성 어려움</h3>
    <ul>
        <li>DB 저장과 MQ 전송을 한 번에 묶는 분산 트랜잭션이 어려움</li>
        <li>둘 중 하나만 성공하면 데이터 정합성 깨짐</li>
    </ul>
    <p><strong>해결 방법: Outbox 패턴, 이중확인 로직, 보상 트랜잭션</strong></p>
    <br>
    <h4>1. Outbox 패턴</h4>
    DB에 메시지를 같이 저장하고, 나중에 큐로 전송하는 방식<br><br>
    <ul>
        <li>트랜잭션 안에서 응답 데이터 저장, Outbox 테이블에 메시지도 함께 저장</li>
        <li>별도 프로세스(이벤트 퍼블리셔)가 Outbox 테이블을 읽어서 MQ로 전송</li>
        <li>전송 완료된 메시지는 Outbox에서 삭제하거나 상태 변경</li>
        <br>
        <li>장점: DB 저장과 메시지 저장이 하나의 트랜잭션으로 묶임 → 정합성 보장 + 유실 방지</li>
    </ul>
    <br>
    <h4>2. 이중확인 로직</h4>
    DB 저장과 MQ 전송이 따로라면, 한 쪽이 실패했을 때 다시 확인해서 재처리<br><br>
    <ul>
        <li>DB 저장 성공 & MQ 전송 실패: 배치나 백그라운드 워커가 미전송 데이터 재전송</li>
        <li>DB 저장 실패 & MQ 전송 성공: 메시지에 포함된 ID로 DB 저장 여부 재확인 → 실패 시 롤백 또는 보상</li>
    </ul>
    <br>
    <h4>3. 보상 트랜잭션</h4>
    <ul>
        <li>한 쪽만 성공해서 정합성이 깨졌다면, 후속 작업으로 실패 이전 상태로 되돌리자</li>
        <li>ex) 상품 주문 메시지는 전송 되었지만 결제 실패 등의 이유로 DB 저장 실패 시, 이미 감소된 재고를 다시 복원</li>
    </ul>
    <br>
    <details>
    <summary><h3>AMQP (Advanced Message Queuing Protocol)</h3></summary>
    <p><strong>서로 다른 시스템 간 메시지를 주고받기 위한 메시징 프로토콜 표준</strong><br>
    HTTP가 웹 통신의 표준이라면, AMQP는 MQ 통신의 표준</p>
    <br>
    * 이름에 Advanced가 붙은 이유는?<br>
    기존에는 MQ 시스템이 회사마다 제각각이었는데,<br>
    AMQP는 누구나 사용할 수 있는 공개된 메시징 규칙을 만들고, 고급 기능까지 표준으로 정의했기 때문에<br>
    <br>
    <h3>AMQP의 특징</h3>
    <ol>
        <li><strong>브로커/클라이언트 간 일관된 동작</strong><br>
        메시지를 송신(Producer)하거나 수신(Consumer)하는 방식을 표준화<br>
        어떤 AMQP 브로커를 사용하든 동일한 방식으로 통신 가능<br>
        - 브로커: 메시지 큐 시스템 (ex: RabbitMQ, ActiveMQ)<br>
        - 클라이언트: AMQP를 사용하는 어플리케이션 또는 시스템<br><br>
        </li>
        <li><strong>네트워크 명령어 표준화</strong><br>
        메시지 송수신 시 사용하는 명령어와 데이터(패킷) 구조를 사전에 정의<br>
        브로커와 클라이언트 간의 정확한 메시지 해석 보장<br><br>
        </li>
        <li><strong>언어 독립성</strong><br>
        AMQP는 네트워크 프로토콜이므로 특정 언어에 종속되지 않음<br>
        어떤 언어로도 AMQP 클라이언트를 구현할 수 있고 호환성 확보<br>
        </li>
    </ol>
    <br>
    <h3>🐰 RabbitMQ가 가장 널리 사용되는 이유</h3>
    <strong>1. 가볍고 설치/운영이 쉽다.</strong><br>
    설치와 설정이 간단하고, 운영도 직관적이어서 초보자도 빠르게 사용할 수 있다.<br><br>
    <strong>2. 기능이 풍부하면서도 유연하다.</strong><br>
    다양한 Exchange 타입(Direct, Fanout, Topic, Headers)을 지원해 라우팅 유연성이 높다.<br>
    또한 메시지 우선순위, 지연 큐(Delay Queue), TTL, Dead Letter Queue 등 고급 기능도 제공한다.<br><br>
    <strong>3. 클러스터링과 플러그인 지원 (확장성과 실무 유연성)</strong><br>
    - 고가용성을 위한 클러스터 구성이 가능해 장애에 대비할 수 있다.<br>
    - Prometheus, MQTT, STOMP, Shovel 등 다양한 플러그인을 통해 모니터링, 외부 시스템 연동, 프로토콜 확장 등이 가능하다.<br><br>
    엄청난 처리량(= 단위 시간당 수십만~수백만 메시지 처리)이나 실시간 분석이 필요한 경우가 아니라,<br>
    서비스 간 메시지 전달, 알림, 이벤트 처리, 작업 분산이 목적이라면 RabbitMQ는 쉽고 빠르고 충분한 선택<br><br>
    ✔ 일반적인 서비스의 비동기 처리 (작업 분산, 알림, 이벤트 전달) → <strong>RabbitMQ</strong><br>
    ✔ 실시간 로그 수집, 이벤트 스트리밍, 대용량 분석 처리 → <strong>Kafka</strong><br>
    <br>
    <h3>AMQP 라우팅 모델 구성 요소</h3>
    <table border="1" cellspacing="0" cellpadding="5">
        <thead>
        <tr>
            <th>구성 요소</th>
            <th>설명</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td><strong>Exchange</strong></td>
            <td>Publisher로부터 메시지를 받아 어떤 Queue로 보낼지 결정하는 라우터</td>
        </tr>
        <tr>
            <td><strong>Queue</strong></td>
            <td>실제 메시지를 저장하고 Consumer가 수신하는 메시지 저장소</td>
        </tr>
        <tr>
            <td><strong>Binding</strong></td>
            <td>Exchange와 Queue 사이의 연결 관계를 정의하는 라우팅 규칙</td>
        </tr>
        </tbody>
    </table>
    <p>※ 라우팅 키: 메시지를 보낼 때 Publisher가 메시지 헤더에 포함시켜 보내는 문자열<br>
    이 문자열을 기반으로 Exchange가 메시지를 어떤 Queue로 보낼지 판단함.<br>
    라우팅 키는 Exchange 타입에 따라 다르게 쓰임!<br><br>
    - Routing Key = 발신 주소<br>
    - Binding Key = 수신 조건</p>
    <br>
    <h3>AMQP의 Exchange 종류</h3>
    <table border="1" cellspacing="0" cellpadding="5">
        <thead>
        <tr>
            <th>종류</th>
            <th>설명</th>
            <th>라우팅 방식</th>
            <th>사용 예시</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td><strong>Direct</strong></td>
            <td>Routing key가 정확히 일치하는 Queue로 전달</td>
            <td>routing key == binding key</td>
            <td>주문 상태 알림, 특정 사용자 메시지</td>
        </tr>
        <tr>
            <td><strong>Fanout</strong></td>
            <td>연결된 모든 Queue로 메시지를 전달 (브로드캐스트)</td>
            <td>Routing key 무시</td>
            <td>공지사항, 로그 브로드캐스트</td>
        </tr>
        <tr>
            <td><strong>Topic</strong></td>
            <td>패턴 기반 라우팅 ('.' 구분자 사용, * / # 와일드카드)</td>
            <td>유연한 다중 대상 매칭<br>
            하나의 Queue가 여러 그룹을 유연하게 수신 가능 (카테고리 단위로 받을 수 있음)</td>
            <td>뉴스 주제, 구독 기반 피드</td>
        </tr>
        <tr>
            <td><strong>Headers</strong></td>
            <td>메시지 헤더의 key-value 조건으로 라우팅
            </td>
            <td>복잡한 조건 기반<br>(라우팅 키로는 부족하고, 조건이 더 복잡할 때)</td>
            <td>메타데이터 기반 필터링 필요 시</td>
        </tr>
        </tbody>
    </table>
    </details>

</details>
