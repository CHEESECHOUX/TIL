# 성능 최적화

<details>
    <summary><h2>응답 시간과 처리량</h2></summary>
    <strong>네트워크 속도, 디스크 속도, 메모리 크기, 디바이스(스마트폰)의 CPU 속도</strong> 등이 성능과 관련되어 있다.<br>
    <strong>서버 성능과 관련 있는 중요한 지표</strong>를 2가지 꼽자면 <strong>응답 시간과 처리량</strong><br>
    <br>
    <h2>1. 응답 시간</h2>
    <h3>응답 시간 = 사용자의 요청을 처리하는 데 걸리는 시간</h3>
    <p>서버는 로직을 실행한 다음, 응답 데이터를 클라이언트에 전송한다.<br>
    응답 데이터를 전송할 때는 API 요청 과정에서 서버와 연결된 소켓을 이용한다.</p>
    <br>
    <ul>
        <li><strong>TTFB (Time to First Byte):</strong> 응답 데이터 중 <strong>첫 번째 바이트가 도착</strong>할 때까지 걸린 시간</li>
        <li><strong>TTLB (Time to Last Byte):</strong> 응답 데이터의 <strong>마지막 바이트가 도착</strong>할 때 걸린 시간</li>
    </ul>
    <p>응답 데이터의 크기가 작다면 TTFB와 TTLB의 차이가 크지 않다. 하지만 파일 다운로드처럼 전송할 데이터가 크거나 네트워크 속도가 느리면 TTFB와 TTLB의 차이가 커질 수 있다. 
    <strong>데이터 특성이나 네트워크 환경을 고려해 TTFB와 TTLB중 적절한 지표를 선택</strong>해 측정해야 한다.</p> 
    <br>
    <p>응답 시간은 1초보다 짧을 때가 많아, 성능 측정을 위해 1/1000초인 밀리초(ms) 단위를 사용한다.</p>
    <br>
    <h3>응답 시간의 구성</h3>
    <ul>
        <li>API 요청 전송 시간</li>
        <li>서버의 처리 시간</li>
        <li>API 응답 전송 시간</li>
    </ul>
    <p>서버 개발자는 주로 <strong>서버의 처리 시간</strong>을 확인한다.</p>
    <br>
    <h3>서버 처리 시간 구성 요소</h3>
    <ul>
        <li>로직 수행 (if, for 등)</li>
        <li>DB 연동</li>
        <li>외부 API 연동</li>
        <li>응답 데이터 생성 (전송)</li>
    </ul>
    ⭐️ 이 중에서도 <strong>DB 연동</strong>과 <strong>외부 API 연동</strong> 시간이 처리 시간의 대부분을 차지하므로, <strong>응답 시간을 줄이기 위해서는 이 두 부분을 집중적으로 최적화</strong>해야 한다.<br>
    <br><br>
    <h2>2. 처리량</h2>
    <h3>처리량 = 단위 시간당 시스템이 처리하는 작업량</h3>
    <br>
    ⭐️ TPS는 <strong>시스템이 처리할 수 있는 최대 요청 수</strong>를 의미</p>
    <ul>
        <li><strong>TPS (transactions per second):</strong> 초당 트랜잭션 수</li>
        <li><strong>RPS (requests per second):</strong> 초당 요청 수</li>
    </ul>
    <br>
    <p>ex) 서버가 한 번에 5개의 요청을 처리할 수 있다고 가정하면,<br>
    이때 요청당 처리 시간이 1초라면 최대 TPS는 5<br><br>동시에 들어오는 요청 수가 최대 TPS를 초과하면 초과한 요청을 나중에 처리한다.<br>
    <br>
    동시에 7개의 요청이 들어오면 나중에 처리된 2개의 요청 시간은 응답 시간이 2초가 된다.<br>
    (기다리는 시간 1초 + 실제 처리한 시간 1초)</p>
    <br><br>
    <p><strong>요청이 최대 TPS를 초과하면 응답 시간이 지연</strong>된다. 
    응답 시간의 증가는 사용자 이탈로 이어질 수 있다.</p><br>
    <h3>💡 사용자 이탈을 막기 위해 TPS를 높이려면?</h3>
    <ul>
        <li><strong>동시에 처리할 수 있는 요청 수를 늘려</strong> 대기 시간 줄이기</li>
        <li><strong>처리 시간 자체를 줄여</strong> 대기 시간 줄이기</li>
    </ul>
    <br>
    <p><strong>트래픽이 많은 시간대의 TPS와 응답 시간이 얼마인지 측정</strong>하고, 이를 바탕으로 <strong>목표 TPS와 응답 시간을 설정</strong>하고 효과적인 <strong>성능 개선안을 도출</strong>해야 한다.</p>
    <br>
    <p>* TPS를 확인하는 가장 간단한 방법<br>
    모니터링 시스템 (ex: 스카우터, 핀포인트, 뉴렐릭)</p>
    <br>
</details>

<details>
    <summary><h2>병목 지점</h2></summary>
    <h2>병목 지점</h2>
    <p>서비스 초기에는 성능 문제가 발생하지 않는다. <strong>성능 문제는 사용자가 늘면서 점차 나타난다.</strong><br>트래픽이 늘고 데이터가 쌓이면서 간헐적으로 응답 시간이 느려지는 현상이 발생한다.</p>
    <br>
    <strong><h3>✔️ 심각한 성능 문제 예시</h3></strong>
    <ul>
        <li>순간적으로 모든 사용자 요청에 대한 응답 시간이 심각하게 느려진다.<br>10초 이상 걸리는 요청이 늘어나고 다수의 요청에서 연결 시간 초과와 같은 오류가 발생한다.</li>
        <li>서버를 재시작하면 잠시 괜찮다가 다시 응답 시간이 느려지는 현상이 반복된다.</li>
        <li>트래픽이 줄어들 때까지 심각한 상황이 계속된다.</li>
    </ul>
    <br>
    <p>트래픽이 증가하면서 성능 문제가 발생하는 주된 이유는 ⭐️ <strong>시스템이 수용할 수 있는 최대 TPS를 초과하는 트래픽이 유입</strong>되기 때문 이다.<br>
        <strong>TPS를 높이려면 성능 문제가 발생하는 지점을 찾아야 한다.</strong> 문제 지점을 찾는 간단한 방법은 <strong>모니터링 도구를 통해 실제 실행 시간을 측정</strong>해, <strong>처리 시간이 오래 걸리는 작업을 찾는 것</strong>이다.<br>
        <br>
        적절한 <strong>모니터링 도구가 없다면 의심되는 코드의 실행 시간을 로그로 남겨야 한다.</strong> 나중에 성능 문제가 다시 발생했을 때 개선할 부분을 찾는 데 도움이 된다.<br>
        <br>
        <strong>성능 문제는 DB나 외부 API를 연동하는 과정에서 주로 발생</strong>한다.
    </p>
</details>

<details>
    <summary><h2>수직 확장과 수평 확장</h2></summary>
    <h2>수직 확장과 수평 확장</h2>
    <p>사용자가 서비스를 이용하지 못하는 상황에서 이를 방치한 채 시간이 오래 걸리는 개선 방안을 시도할 수 없다.</p>
    <br>
    <p><strong>급하게 해결할 수 있는 방법</strong></p>
    <ul>
        <li><strong>수직 확장</strong>: CPU, 메모리, 디스크 등의 자원을 증가시키는 것</li>
        <li><strong>수평 확장</strong>: 서버 개수를 늘리는 방법<br>
        (서버가 두 대 이상이면 로드 밸런서로 사용자 트래픽을 각 서버에 골고루 분배해줘야 한다.)
        </li>
    </ul>
    <br>
    <p>⭐️ <strong>DB에서 성능 문제가 발생하고 있는데, 서버를 추가로 투입하면 불에 기름을 붓는 격</strong>이다.<br>
    → DB에 문제가 있는 상황에서 DB를 사용하는 서버를 더 늘리면 DB에 가해지는 부하가 더 커짐.</p>
    <p>외부 API 성능이 문제인 경우, 외부 API의 성능이 개선되지 않는 한 서버를 추가한다고 해도 TPS는 향상되지 않는다.</p>
    <br>
    <p><strong>DB나 외부 API에 성능 문제가 발생하지 않는 범위 내에서만 수평 확장</strong>을 해야 효과가 있다.<br>
    (ex: 서버 CPU 사용률이 높을 때, 메모리 부족일 경우, 정적 파일 서빙, 캐시 처리 위주 트래픽 급증일 경우)</p>
    <br><br>
    <p><strong>Q. 수직 확장만 하면 안 되나요?</strong><br>
        수직 확장은 즉각적인 효과를 바로 얻을 수 있지만 트래픽이 지속해서 증가하면 언젠가 또다시 성능 문제가 발생한다.<br>
        <strong>비용이 많이 들기 때문</strong>에, 매번 수직 확장을 반복할 수 없다. 또한 <strong>한 대의 장비가 감당할 수 있는 용량에도 한계</strong>가 있다.<br>
        트래픽이 증가하면 서버를 추가로 투입해 TPS를 높이는 방법(= 수평 확장)도 고려해야 한다.
    </p>

</details>

<details>
    <summary><h2>DB 커넥션 풀</h2></summary>
    <h2>DB 커넥션 풀</h2>
    <p><strong>DB를 사용하려면?</strong></p>
    <ul>
        <li>1. DB에 연결</li>
        <li>2. 쿼리 실행</li>
        <li>3. 연결 종료</li>
    </ul>
    <br>
    <summary><h2>1. DB 커넥션 풀을 사용하는 이유</h2></summary>
    <p>서버와 DB는 네트워크 통신을 통해 연결된다. 이때 네트워크 연결을 생성하고 종료하는데 걸리는 시간은 0.5초에서 1초 이상 소요되기도 한다.</p>
    <p>⭐️ <strong>네트워크에서 DB를 연결하고 종료하는 시간은 전체 응답 시간에 영향</strong>을 준다.</p>
    <ul>
        <li>1. <strong>응답 시간이 길어지면 전체 처리량은 떨어진다.</strong> 트래픽이 증가하면 이러한 현상은 더 두드러진다.</li>
        <li>2. <strong>매 요청마다 DB를 연결하고 종료하면, 트래픽이 증가할 때 급격하게 처리량이 떨어지기도 한다.</strong></li>
    </ul>
    <p>이러한 문제를 피하기 위해 DB 커넥션 풀을 사용하는 것!</p>
    <br><br>
    <summary><h2>2. DB 커넥션 풀이란?</h2></summary>
    <p>DB 커넥션 풀은 <strong>DB에 연결된 커넥션을 미리 생성해서 보관</strong>한다.</p>
    <br>
    <p>서버가 시작될 때 설정된 커넥션 풀의 최소 개수만큼 미리 DB에 연결을 맺음.</p>
    <p>⭐️ 애플리케이션은 <strong>DB 작업이 필요할 때 풀에서 커넥션을 가져와 사용</strong>하고, <strong>작업이 끝나면 다시 풀에 반환</strong>한다.</p>
    <p>⭐️ <strong>이미 연결된 커넥션을 재사용</strong>하기 때문에 <strong>응답 시간이 줄어드는 장점</strong></p>
    <br><br>
    <summary><h2>3. DB 커넥션 풀 설정</h2></summary>
    <p><h3>3-1. 커넥션 풀 크기</h3></p>
    <p><strong>커넥션 풀에 미리 생성해둘 커넥션 개수를 지정하는 설정.</strong><br>
    풀의 <strong>모든 커넥션이 사용 중이면, 다른 요청은 풀에 유휴 커넥션이 생길 때까지 대기</strong>하게 된다.<br>
    풀에서 커넥션을 얻기 위해 대기하는 시간을 줄이려면, <strong>전체 응답 시간과 TPS를 고려해 크기를 지정</strong>해야 한다. <strong>최소 크기와 최대 크기를 설정</strong>할 수 있다.</p>
    <p>커넥션 풀 크기가 5이고 한 요청에서 쿼리를 실행하는데 0.1초가 걸린다면? 1초에 처리할 수 있는 요청 수는 50이 된다. (1초에 10번 처리가능 * 5개)</p>
    <br>
    <p>⭐️ <strong>커넥션 풀 크기는 DB 상태를 보고 늘려야 한다.</strong><br>
    DB 서버의 CPU 사용률이 80%에 육박하는 상황에서 커넥션 풀 크기를 늘리면 DB에 가해지는 부하가 더 커져 쿼리 실행 시간이 급격히 증가할 수 있다.</p>
    <p>만약, 이 상태에서 <strong>커넥션 풀 크기를 늘리면 DB는 더 많은 쿼리를 병렬로 실행하려다 더 심하게 느려지게 된다.</strong></p>
    <p><strong>DB는 CPU, 메모리, I/O 등 리소스를 공유하는 구조</strong>이다. 커넥션이 많아져 동시에 다량의 쿼리가 들어오면, <strong>멀티태스킹을 하느라 오히려 더 느려짐.</strong> (컨텍스트 스위칭, 락 경합, 디스크 I/O 대기 등 발생 가능)</p>
    <p>→ 이런 경우에는 <strong>커넥션 풀 크기를 유지하거나 줄여서 DB 서버가 포화 상태에 이르지 않도록 해야한다.</strong></p>
    <br>
    <p>주방에 요리사가 4명만 있는데 100개의 주문이 들어오면? 요리사가 정신없이 뛰어다니지만 점점 느려짐<br>
    한 번에 10개의 주문만 받게 하면? 대기 줄은 길지만, 요리는 빠르고 정확하게 나옴</p>
    <br>
    <p><h3>3-2. 커넥션 대기 시간</h3></p>
    <p><strong>풀에 사용할 수 있는 커넥션이 없을 때, 커넥션을 얻기 위해 기다릴 수 있는 최대 시간</strong><br>
    <strong>대기하는 시간만큼 응답 시간도 길어진다.</strong> 보통의 경우라면 <strong>대기 시간을 0.5초에서 3초 이내로 지정</strong>한다.</p>
    <br>
    <p><strong>대기 시간을 짧게 설정</strong>하면 커넥션 풀이 모두 사용 중일 때 <strong>'일시적 오류'와 같은 에러 응답을 사용자에게 보여줄 수 있다.</strong></p>
    <p>⭐️ <strong>빠르게 에러를 반환</strong>하는 것이 긴 시간 동안 <strong>무응답 상태로 유지되는 것보다 낫고, 서버의 부하 증가도 방지</strong>한다.</p>
    <p>대기 시간을 짧게 설정하지 않으면, 몇 초만에 요청을 취소하고 <strong>재요청을 하는 사용자가 반복</strong> 된다. <strong>클라이언트가 요청을 취소하더라도 서버는 일정 시간 동안 하던 작업을 즉시 중단하지 않기 때문</strong>에 동시에 처리해야 할 <strong>요청 수는 계속 쌓이고 증가</strong>한다. → 그만큼 서버에 가해지는 부하도 커짐</p>
    <br>
    <p><h3>3-3. 커넥션의 유지 시간</h3></p>
    <p>MySQL과 같은 DB는 클라이언트와 <strong>일정 시간 동안 상호작용이 없으면 자동으로 연결을 끊는 기능을 제공</strong>한다.</p>
    <p>⭐️ <strong>DB와의 연결이 끊긴 커넥션을 사용하면 에러가 발생</strong>하기 때문에, 커넥션 풀은 이를 방지하기 위해 2가지 기능을 제공한다.</p>
    <br>
    <ul>
    <li><strong>1. 최대 유휴 시간 지정</strong><br>
    <strong>최대 유휴 시간: 사용되지 않는 커넥션을 풀에 유지할 수 있는 최대 시간</strong><br>
    <strong>최대 유휴 시간을 DB에 설정된 비활성화 유지 시간보다 짧게 설정</strong>하면, <strong>DB가 연결을 끊기 전에 풀에서 커넥션을 제거</strong>할 수 있다.<br>
    DB 비활성 유지시간(timeout)이 더 짧으면 DB와의 연결이 살아있다고 생각하고 커넥션을 꺼내서 쓰려고 하면 오류가 발생함(MySQL server has gone away, broken pipe 등)</li>
    <br>
    <li><strong>2. 유효성 검사 지원</strong><br>
    <strong>유효성 검사: 커넥션이 정상적으로 사용할 수 있는 상태인지 여부를 확인</strong>하는 절차<br>
    커넥션 풀의 구현 방식에 따라, <strong>커넥션을 풀에서 가져올 때 or 주기적으로 검사</strong> 할 수 있다. 이때 <strong>유효하지 않은 커넥션을 식별하고 풀에서 제거</strong>할 수 있다.</li>
    <br>
    <li><strong>3. 최대 유지 시간</strong><br>
    <strong>최대 유지 시간: 커넥션이 생성된 시점부터 최대 유지되는 시간</strong><br>
    커넥션이 유효하더라도 최대 유지 시간이 지나면 풀에서 제거된다.</li>
    </ul>
</details>
